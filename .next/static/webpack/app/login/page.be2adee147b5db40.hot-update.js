"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/login/page",{

/***/ "(app-pages-browser)/./services/auth.ts":
/*!**************************!*\
  !*** ./services/auth.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearTokens: () => (/* binding */ clearTokens),\n/* harmony export */   getAccessToken: () => (/* binding */ getAccessToken),\n/* harmony export */   getOrCreateDeviceId: () => (/* binding */ getOrCreateDeviceId),\n/* harmony export */   getTokens: () => (/* binding */ getTokens),\n/* harmony export */   saveTokens: () => (/* binding */ saveTokens)\n/* harmony export */ });\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/db */ \"(app-pages-browser)/./lib/db.ts\");\n/* harmony import */ var _lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/crypto-utils */ \"(app-pages-browser)/./lib/crypto-utils.ts\");\n\n\nconst TOKEN_KEY = \"session\"; // clave fija en IndexedDB\nconst API_BASE = \"https://plugins-indicators-charitable-subtle.trycloudflare.com\";\n// ðŸ”’ Seguridad: Limitar informaciÃ³n expuesta del dispositivo\nfunction getDeviceInfo() {\n    const ua = navigator.userAgent;\n    let os = \"Unknown\";\n    let browser = \"Unknown\";\n    if (ua.indexOf(\"Win\") !== -1) os = \"Windows\";\n    else if (ua.indexOf(\"Mac\") !== -1) os = \"MacOS\";\n    else if (ua.indexOf(\"Linux\") !== -1) os = \"Linux\";\n    else if (/Android/i.test(ua)) os = \"Android\";\n    else if (/iPhone|iPad|iPod/i.test(ua)) os = \"iOS\";\n    if (ua.indexOf(\"Chrome\") !== -1) browser = \"Chrome\";\n    else if (ua.indexOf(\"Safari\") !== -1 && ua.indexOf(\"Chrome\") === -1) browser = \"Safari\";\n    else if (ua.indexOf(\"Firefox\") !== -1) browser = \"Firefox\";\n    else if (ua.indexOf(\"Edg\") !== -1) browser = \"Edge\";\n    // ðŸ”’ No exponer userAgent completo, solo hash\n    const uaHash = crypto.subtle ? hashString(ua) : \"legacy\";\n    return {\n        os,\n        browser,\n        uaHash\n    };\n}\n// Hash simple para userAgent\nfunction hashString(str) {\n    let hash = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash;\n    }\n    return Math.abs(hash).toString(36);\n}\nasync function getOrCreateDeviceId() {\n    // Buscar en la cache\n    let cache = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.auth.get(\"device\");\n    if (cache === null || cache === void 0 ? void 0 : cache.deviceId) {\n        return cache.deviceId; // âœ… ya existe, lo reutilizamos\n    }\n    try {\n        // Generar por primera vez\n        const info = getDeviceInfo();\n        const newId = {\n            uuid: crypto.randomUUID(),\n            os: info.os,\n            browser: info.browser,\n            uaHash: info.uaHash,\n            createdAt: new Date().toISOString()\n        };\n        const deviceIdStr = JSON.stringify(newId);\n        const deviceId = JSON.parse(deviceIdStr);\n        // Guardamos en IndexedDB en un registro separado \"device\"\n        await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.devices.put({\n            id: \"device\",\n            deviceId\n        });\n        return deviceId;\n    } catch (e) {\n        console.log(\"Error al crear DeviceId en auth.ts \", e);\n    }\n    return \"\";\n}\n/** ðŸ”¹ Guardar tokens en IndexedDB */ async function saveTokens(tokens) {\n    await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.tokens.put(tokens);\n}\n/** ðŸ”¹ Leer tokens de IndexedDB */ async function getTokens() {\n    const record = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.tokens.get(TOKEN_KEY);\n    if (!record) return null;\n    var _record_refreshToken;\n    return {\n        id: TOKEN_KEY,\n        accessToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.decryptData)(record.accessToken),\n        refreshToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.decryptData)((_record_refreshToken = record.refreshToken) !== null && _record_refreshToken !== void 0 ? _record_refreshToken : \"\"),\n        expiresAt: record.expiresAt,\n        usuarioConfiguracion: record.usuarioConfiguracion\n    };\n}\n/** ðŸ”¹ Borrar tokens â†’ logout */ async function clearTokens() {\n    await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.auth.delete(TOKEN_KEY);\n    await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.tokens.delete(TOKEN_KEY);\n}\n/** ðŸ”¹ Refrescar token */ async function refreshToken(refreshToken) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n    try {\n        const res = await fetch(\"\".concat(API_BASE, \"/auth/refresh\"), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"Bearer \".concat(refreshToken)\n            }\n        });\n        const data = await res.json();\n        if (!res.ok) {\n            // ðŸ”’ Seguridad: Si el refresh falla, limpiar sesiÃ³n\n            if (res.status === 401 || res.status === 403) {\n                await clearTokens();\n                throw new Error(\"SesiÃ³n expirada. Por favor, inicia sesiÃ³n nuevamente.\");\n            }\n            throw new Error(\"Error al refrescar token: \" + JSON.stringify(data));\n        }\n        const expiresIn = 15 * 60 * 1000;\n        const tokens = {\n            id: TOKEN_KEY,\n            accessToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.encryptData)(data.accessToken),\n            refreshToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.encryptData)(data.refreshToken),\n            expiresAt: Date.now() + expiresIn,\n            usuarioConfiguracion: data.usuarioConfiguracionList\n        };\n        await saveTokens(tokens);\n        var _tokens_refreshToken;\n        return {\n            id: TOKEN_KEY,\n            accessToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.decryptData)(tokens.accessToken),\n            refreshToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.decryptData)((_tokens_refreshToken = tokens.refreshToken) !== null && _tokens_refreshToken !== void 0 ? _tokens_refreshToken : \"\"),\n            expiresAt: tokens.expiresAt,\n            usuarioConfiguracion: tokens.usuarioConfiguracion\n        };\n    } catch (error) {\n        // ðŸ”’ Retry logic para errores de red\n        if (retries > 0 && !(error instanceof Error && error.message.includes(\"SesiÃ³n expirada\"))) {\n            console.warn(\"Reintentando refresh token... (intentos restantes: \".concat(retries, \")\"));\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            return refreshToken(refreshToken, retries - 1);\n        }\n        throw error;\n    }\n}\n/** ðŸ”¹ Obtener accessToken vÃ¡lido (renueva si expirÃ³) */ async function getAccessToken() {\n    let tokens = await getTokens();\n    if (!tokens) {\n        throw new Error(\"No hay sesiÃ³n activa\");\n    }\n    if (Date.now() >= tokens.expiresAt) {\n        tokens = await refreshToken(tokens.refreshToken);\n    }\n    return tokens.accessToken;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxjQUFhLE1BQU12RCw4REFBV0EsQ0FBQ2tFLEtBQUtYLFlBQVk7WUFDaERDLFdBQVdsQixLQUFLa0MsR0FBRyxLQUFLRDtZQUN4QmQsc0JBQXNCUyxLQUFLTyx3QkFBd0I7UUFDckQ7UUFFQSxNQUFNdkIsV0FBV0M7WUFJaUJBO1FBSGxDLE9BQU87WUFDTEwsSUFBRzVDO1lBQ0hvRCxhQUFhLE1BQU1yRCw4REFBV0EsQ0FBQ2tELE9BQU9HLFdBQVc7WUFDakRDLGNBQWMsTUFBTXRELDhEQUFXQSxDQUFDa0QsQ0FBQUEsdUJBQUFBLE9BQU9JLFlBQVksY0FBbkJKLGtDQUFBQSx1QkFBdUI7WUFDdkRLLFdBQVdMLE9BQU9LLFNBQVM7WUFDM0JDLHNCQUFzQk4sT0FBT00sb0JBQW9CO1FBQ25EO0lBQ0YsRUFBRSxPQUFPaUIsT0FBTztRQUNkLHFDQUFxQztRQUNyQyxJQUFJZCxVQUFVLEtBQUssQ0FBRWMsQ0FBQUEsaUJBQWlCSixTQUFTSSxNQUFNQyxPQUFPLENBQUNDLFFBQVEsQ0FBQyxrQkFBaUIsR0FBSTtZQUN6RjVCLFFBQVE2QixJQUFJLENBQUMsc0RBQThELE9BQVJqQixTQUFRO1lBQzNFLE1BQU0sSUFBSWtCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFDakQsT0FBT3hCLGFBQWFBLGNBQWNLLFVBQVU7UUFDOUM7UUFDQSxNQUFNYztJQUNSO0FBQ0Y7QUFFQSxzREFBc0QsR0FDL0MsZUFBZU87SUFDcEIsSUFBSTlCLFNBQVMsTUFBTUM7SUFDbkIsSUFBSSxDQUFDRCxRQUFRO1FBQ1gsTUFBTSxJQUFJbUIsTUFBTTtJQUNsQjtJQUVBLElBQUloQyxLQUFLa0MsR0FBRyxNQUFNckIsT0FBT0ssU0FBUyxFQUFFO1FBQ2xDTCxTQUFTLE1BQU1JLGFBQWFKLE9BQU9JLFlBQVk7SUFDakQ7SUFFQSxPQUFPSixPQUFPRyxXQUFXO0FBQzNCIiwic291cmNlcyI6WyJDOlxcZGVzYXJyb2xsb19yZWFjdFxccHJldmVudGFcXHNvZnR3YXJlLWNvbWVyY2lhbFxcc2VydmljZXNcXGF1dGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGIgfSBmcm9tIFwiLi4vbGliL2RiXCI7XHJcbmltcG9ydCB7IGVuY3J5cHREYXRhLCBkZWNyeXB0RGF0YSB9IGZyb20gXCIuLi9saWIvY3J5cHRvLXV0aWxzXCI7XHJcbmltcG9ydCB7IFRva2VucyB9IGZyb20gXCIuLi9saWIvdHlwZXNcIjtcclxuXHJcbmNvbnN0IFRPS0VOX0tFWSA9IFwic2Vzc2lvblwiOyAvLyBjbGF2ZSBmaWphIGVuIEluZGV4ZWREQlxyXG5jb25zdCBBUElfQkFTRSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XHJcblxyXG4vLyDwn5SSIFNlZ3VyaWRhZDogTGltaXRhciBpbmZvcm1hY2nDs24gZXhwdWVzdGEgZGVsIGRpc3Bvc2l0aXZvXHJcbmZ1bmN0aW9uIGdldERldmljZUluZm8oKSB7XHJcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gIGxldCBvcyA9IFwiVW5rbm93blwiO1xyXG4gIGxldCBicm93c2VyID0gXCJVbmtub3duXCI7XHJcblxyXG4gIGlmICh1YS5pbmRleE9mKFwiV2luXCIpICE9PSAtMSkgb3MgPSBcIldpbmRvd3NcIjtcclxuICBlbHNlIGlmICh1YS5pbmRleE9mKFwiTWFjXCIpICE9PSAtMSkgb3MgPSBcIk1hY09TXCI7XHJcbiAgZWxzZSBpZiAodWEuaW5kZXhPZihcIkxpbnV4XCIpICE9PSAtMSkgb3MgPSBcIkxpbnV4XCI7XHJcbiAgZWxzZSBpZiAoL0FuZHJvaWQvaS50ZXN0KHVhKSkgb3MgPSBcIkFuZHJvaWRcIjtcclxuICBlbHNlIGlmICgvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QodWEpKSBvcyA9IFwiaU9TXCI7XHJcblxyXG4gIGlmICh1YS5pbmRleE9mKFwiQ2hyb21lXCIpICE9PSAtMSkgYnJvd3NlciA9IFwiQ2hyb21lXCI7XHJcbiAgZWxzZSBpZiAodWEuaW5kZXhPZihcIlNhZmFyaVwiKSAhPT0gLTEgJiYgdWEuaW5kZXhPZihcIkNocm9tZVwiKSA9PT0gLTEpIGJyb3dzZXIgPSBcIlNhZmFyaVwiO1xyXG4gIGVsc2UgaWYgKHVhLmluZGV4T2YoXCJGaXJlZm94XCIpICE9PSAtMSkgYnJvd3NlciA9IFwiRmlyZWZveFwiO1xyXG4gIGVsc2UgaWYgKHVhLmluZGV4T2YoXCJFZGdcIikgIT09IC0xKSBicm93c2VyID0gXCJFZGdlXCI7XHJcblxyXG4gIC8vIPCflJIgTm8gZXhwb25lciB1c2VyQWdlbnQgY29tcGxldG8sIHNvbG8gaGFzaFxyXG4gIGNvbnN0IHVhSGFzaCA9IGNyeXB0by5zdWJ0bGUgPyBoYXNoU3RyaW5nKHVhKSA6IFwibGVnYWN5XCI7XHJcbiAgcmV0dXJuIHsgb3MsIGJyb3dzZXIsIHVhSGFzaCB9O1xyXG59XHJcblxyXG4vLyBIYXNoIHNpbXBsZSBwYXJhIHVzZXJBZ2VudFxyXG5mdW5jdGlvbiBoYXNoU3RyaW5nKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuICBsZXQgaGFzaCA9IDA7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGNoYXI7XHJcbiAgICBoYXNoID0gaGFzaCAmIGhhc2g7XHJcbiAgfVxyXG4gIHJldHVybiBNYXRoLmFicyhoYXNoKS50b1N0cmluZygzNik7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0ZURldmljZUlkKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgLy8gQnVzY2FyIGVuIGxhIGNhY2hlXHJcbiAgbGV0IGNhY2hlID0gYXdhaXQgZGIuYXV0aC5nZXQoXCJkZXZpY2VcIik7XHJcbiAgaWYgKGNhY2hlPy5kZXZpY2VJZCkge1xyXG4gICAgcmV0dXJuIGNhY2hlLmRldmljZUlkOyAvLyDinIUgeWEgZXhpc3RlLCBsbyByZXV0aWxpemFtb3NcclxuICB9XHJcbiAgdHJ5e1xyXG4gICAgLy8gR2VuZXJhciBwb3IgcHJpbWVyYSB2ZXpcclxuICAgIGNvbnN0IGluZm8gPSBnZXREZXZpY2VJbmZvKCk7XHJcbiAgICBjb25zdCBuZXdJZCA9IHtcclxuICAgICAgdXVpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgb3M6IGluZm8ub3MsXHJcbiAgICAgIGJyb3dzZXI6IGluZm8uYnJvd3NlcixcclxuICAgICAgdWFIYXNoOiBpbmZvLnVhSGFzaCwgLy8g8J+UkiBTb2xvIGhhc2gsIG5vIHVzZXJBZ2VudCBjb21wbGV0b1xyXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZGV2aWNlSWRTdHIgPSBKU09OLnN0cmluZ2lmeShuZXdJZCk7XHJcbiAgICBjb25zdCBkZXZpY2VJZCA9IEpTT04ucGFyc2UoZGV2aWNlSWRTdHIpO1xyXG4gICAgLy8gR3VhcmRhbW9zIGVuIEluZGV4ZWREQiBlbiB1biByZWdpc3RybyBzZXBhcmFkbyBcImRldmljZVwiXHJcbiAgICAgIGF3YWl0IGRiLmRldmljZXMucHV0KHtcclxuICAgICAgICBpZDogXCJkZXZpY2VcIixcclxuICAgICAgICBkZXZpY2VJZCxcclxuICAgICAgfSk7XHJcbiAgICByZXR1cm4gZGV2aWNlSWQ7XHJcbiAgfWNhdGNoKGUpe1xyXG4gICAgY29uc29sZS5sb2coXCJFcnJvciBhbCBjcmVhciBEZXZpY2VJZCBlbiBhdXRoLnRzIFwiLGUpO1xyXG4gIH1cclxuICByZXR1cm4gXCJcIjtcclxufVxyXG5cclxuLyoqIPCflLkgR3VhcmRhciB0b2tlbnMgZW4gSW5kZXhlZERCICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlVG9rZW5zKHRva2VuczogVG9rZW5zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgYXdhaXQgZGIudG9rZW5zLnB1dCh0b2tlbnMpO1xyXG59XHJcblxyXG5cclxuLyoqIPCflLkgTGVlciB0b2tlbnMgZGUgSW5kZXhlZERCICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUb2tlbnMoKTogUHJvbWlzZTxUb2tlbnMgfCBudWxsPiB7XHJcbiAgY29uc3QgcmVjb3JkID0gYXdhaXQgZGIudG9rZW5zLmdldChUT0tFTl9LRVkpO1xyXG4gIGlmICghcmVjb3JkKSByZXR1cm4gbnVsbDtcclxuICByZXR1cm4ge1xyXG4gICAgaWQ6VE9LRU5fS0VZLFxyXG4gICAgYWNjZXNzVG9rZW46IGF3YWl0IGRlY3J5cHREYXRhKHJlY29yZC5hY2Nlc3NUb2tlbiksXHJcbiAgICByZWZyZXNoVG9rZW46IGF3YWl0IGRlY3J5cHREYXRhKHJlY29yZC5yZWZyZXNoVG9rZW4gPz8gXCJcIiksIC8vIPCfkYggZmFsbGJhY2sgc3RyaW5nIHZhY8Otb1xyXG4gICAgZXhwaXJlc0F0OiByZWNvcmQuZXhwaXJlc0F0LFxyXG4gICAgdXN1YXJpb0NvbmZpZ3VyYWNpb246IHJlY29yZC51c3VhcmlvQ29uZmlndXJhY2lvbixcclxuICB9O1xyXG59XHJcblxyXG4vKiog8J+UuSBCb3JyYXIgdG9rZW5zIOKGkiBsb2dvdXQgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFyVG9rZW5zKCkge1xyXG4gIGF3YWl0IGRiLmF1dGguZGVsZXRlKFRPS0VOX0tFWSk7XHJcbiAgYXdhaXQgZGIudG9rZW5zLmRlbGV0ZShUT0tFTl9LRVkpO1xyXG59XHJcblxyXG4vKiog8J+UuSBSZWZyZXNjYXIgdG9rZW4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbjogc3RyaW5nLCByZXRyaWVzID0gMyk6IFByb21pc2U8VG9rZW5zPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9hdXRoL3JlZnJlc2hgLCB7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3JlZnJlc2hUb2tlbn1gIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgLy8g8J+UkiBTZWd1cmlkYWQ6IFNpIGVsIHJlZnJlc2ggZmFsbGEsIGxpbXBpYXIgc2VzacOzblxyXG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxIHx8IHJlcy5zdGF0dXMgPT09IDQwMykge1xyXG4gICAgICAgIGF3YWl0IGNsZWFyVG9rZW5zKCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VzacOzbiBleHBpcmFkYS4gUG9yIGZhdm9yLCBpbmljaWEgc2VzacOzbiBudWV2YW1lbnRlLlwiKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBhbCByZWZyZXNjYXIgdG9rZW46IFwiICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGV4cGlyZXNJbiA9IDE1ICogNjAgKiAxMDAwO1xyXG5cclxuICAgIGNvbnN0IHRva2VuczogVG9rZW5zID0ge1xyXG4gICAgICBpZDpUT0tFTl9LRVksXHJcbiAgICAgIGFjY2Vzc1Rva2VuOiBhd2FpdCBlbmNyeXB0RGF0YShkYXRhLmFjY2Vzc1Rva2VuKSwgXHJcbiAgICAgIHJlZnJlc2hUb2tlbjphd2FpdCBlbmNyeXB0RGF0YShkYXRhLnJlZnJlc2hUb2tlbiksXHJcbiAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIGV4cGlyZXNJbixcclxuICAgICAgdXN1YXJpb0NvbmZpZ3VyYWNpb246IGRhdGEudXN1YXJpb0NvbmZpZ3VyYWNpb25MaXN0XHJcbiAgICB9O1xyXG5cclxuICAgIGF3YWl0IHNhdmVUb2tlbnModG9rZW5zKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOlRPS0VOX0tFWSxcclxuICAgICAgYWNjZXNzVG9rZW46IGF3YWl0IGRlY3J5cHREYXRhKHRva2Vucy5hY2Nlc3NUb2tlbiksXHJcbiAgICAgIHJlZnJlc2hUb2tlbjogYXdhaXQgZGVjcnlwdERhdGEodG9rZW5zLnJlZnJlc2hUb2tlbiA/PyBcIlwiKSwgLy8g8J+RiCBmYWxsYmFjayBzdHJpbmcgdmFjw61vXHJcbiAgICAgIGV4cGlyZXNBdDogdG9rZW5zLmV4cGlyZXNBdCxcclxuICAgICAgdXN1YXJpb0NvbmZpZ3VyYWNpb246IHRva2Vucy51c3VhcmlvQ29uZmlndXJhY2lvbixcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIC8vIPCflJIgUmV0cnkgbG9naWMgcGFyYSBlcnJvcmVzIGRlIHJlZFxyXG4gICAgaWYgKHJldHJpZXMgPiAwICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiU2VzacOzbiBleHBpcmFkYVwiKSkpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBSZWludGVudGFuZG8gcmVmcmVzaCB0b2tlbi4uLiAoaW50ZW50b3MgcmVzdGFudGVzOiAke3JldHJpZXN9KWApO1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xyXG4gICAgICByZXR1cm4gcmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbiwgcmV0cmllcyAtIDEpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKiog8J+UuSBPYnRlbmVyIGFjY2Vzc1Rva2VuIHbDoWxpZG8gKHJlbnVldmEgc2kgZXhwaXLDsykgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjY2Vzc1Rva2VuKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgbGV0IHRva2VucyA9IGF3YWl0IGdldFRva2VucygpO1xyXG4gIGlmICghdG9rZW5zKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYXkgc2VzacOzbiBhY3RpdmFcIik7XHJcbiAgfVxyXG5cclxuICBpZiAoRGF0ZS5ub3coKSA+PSB0b2tlbnMuZXhwaXJlc0F0KSB7XHJcbiAgICB0b2tlbnMgPSBhd2FpdCByZWZyZXNoVG9rZW4odG9rZW5zLnJlZnJlc2hUb2tlbik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdG9rZW5zLmFjY2Vzc1Rva2VuO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJkYiIsImVuY3J5cHREYXRhIiwiZGVjcnlwdERhdGEiLCJUT0tFTl9LRVkiLCJBUElfQkFTRSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiZ2V0RGV2aWNlSW5mbyIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwib3MiLCJicm93c2VyIiwiaW5kZXhPZiIsInRlc3QiLCJ1YUhhc2giLCJjcnlwdG8iLCJzdWJ0bGUiLCJoYXNoU3RyaW5nIiwic3RyIiwiaGFzaCIsImkiLCJsZW5ndGgiLCJjaGFyIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJhYnMiLCJ0b1N0cmluZyIsImdldE9yQ3JlYXRlRGV2aWNlSWQiLCJjYWNoZSIsImF1dGgiLCJnZXQiLCJkZXZpY2VJZCIsImluZm8iLCJuZXdJZCIsInV1aWQiLCJyYW5kb21VVUlEIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZGV2aWNlSWRTdHIiLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2UiLCJkZXZpY2VzIiwicHV0IiwiaWQiLCJlIiwiY29uc29sZSIsImxvZyIsInNhdmVUb2tlbnMiLCJ0b2tlbnMiLCJnZXRUb2tlbnMiLCJyZWNvcmQiLCJhY2Nlc3NUb2tlbiIsInJlZnJlc2hUb2tlbiIsImV4cGlyZXNBdCIsInVzdWFyaW9Db25maWd1cmFjaW9uIiwiY2xlYXJUb2tlbnMiLCJkZWxldGUiLCJyZXRyaWVzIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImRhdGEiLCJqc29uIiwib2siLCJzdGF0dXMiLCJFcnJvciIsImV4cGlyZXNJbiIsIm5vdyIsInVzdWFyaW9Db25maWd1cmFjaW9uTGlzdCIsImVycm9yIiwibWVzc2FnZSIsImluY2x1ZGVzIiwid2FybiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldEFjY2Vzc1Rva2VuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/auth.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/authService.ts":
/*!*********************************!*\
  !*** ./services/authService.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loginService: () => (/* binding */ loginService)\n/* harmony export */ });\nconst API_BASE = \"https://plugins-indicators-charitable-subtle.trycloudflare.com\";\nasync function loginService(username, password, deviceId) {\n    const res = await fetch(\"\".concat(API_BASE, \"/auth/login\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            username,\n            password,\n            deviceId\n        })\n    });\n    if (!res.ok) return null;\n    return res.json(); // { token: \"...\" }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2F1dGhTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFDQSxNQUFNQSxXQUFXQyxnRUFBK0I7QUFHekMsZUFBZUcsYUFBYUMsUUFBZ0IsRUFBRUMsUUFBZ0IsRUFBRUMsUUFBZ0I7SUFDckYsTUFBTUMsTUFBTSxNQUFNQyxNQUFNLEdBQVksT0FBVFQsVUFBUyxnQkFBYztRQUNoRFUsUUFBUTtRQUNSQyxTQUFTO1lBQUUsZ0JBQWdCO1FBQW1CO1FBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7WUFBRVQ7WUFBVUM7WUFBVUM7UUFBUztJQUN0RDtJQUNBLElBQUksQ0FBQ0MsSUFBSU8sRUFBRSxFQUFFLE9BQU87SUFDcEIsT0FBT1AsSUFBSVEsSUFBSSxJQUFJLG1CQUFtQjtBQUN4QyIsInNvdXJjZXMiOlsiQzpcXGRlc2Fycm9sbG9fcmVhY3RcXHByZXZlbnRhXFxzb2Z0d2FyZS1jb21lcmNpYWxcXHNlcnZpY2VzXFxhdXRoU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuY29uc3QgQVBJX0JBU0UgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMO1xyXG5cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2dpblNlcnZpY2UodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgZGV2aWNlSWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9hdXRoL2xvZ2luYCwge1xyXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBkZXZpY2VJZCB9KSxcclxuICB9KTtcclxuICBpZiAoIXJlcy5vaykgcmV0dXJuIG51bGw7XHJcbiAgcmV0dXJuIHJlcy5qc29uKCk7IC8vIHsgdG9rZW46IFwiLi4uXCIgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJBUElfQkFTRSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwibG9naW5TZXJ2aWNlIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImRldmljZUlkIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsImpzb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/authService.ts\n"));

/***/ })

});