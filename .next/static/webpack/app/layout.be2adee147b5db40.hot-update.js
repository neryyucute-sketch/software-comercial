"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/layout",{

/***/ "(app-pages-browser)/./services/auth.ts":
/*!**************************!*\
  !*** ./services/auth.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   clearTokens: () => (/* binding */ clearTokens),\n/* harmony export */   getAccessToken: () => (/* binding */ getAccessToken),\n/* harmony export */   getOrCreateDeviceId: () => (/* binding */ getOrCreateDeviceId),\n/* harmony export */   getTokens: () => (/* binding */ getTokens),\n/* harmony export */   saveTokens: () => (/* binding */ saveTokens)\n/* harmony export */ });\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/db */ \"(app-pages-browser)/./lib/db.ts\");\n/* harmony import */ var _lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../lib/crypto-utils */ \"(app-pages-browser)/./lib/crypto-utils.ts\");\n\n\nconst TOKEN_KEY = \"session\"; // clave fija en IndexedDB\nconst API_BASE = \"https://plugins-indicators-charitable-subtle.trycloudflare.com\";\n// ðŸ”’ Seguridad: Limitar informaciÃ³n expuesta del dispositivo\nfunction getDeviceInfo() {\n    const ua = navigator.userAgent;\n    let os = \"Unknown\";\n    let browser = \"Unknown\";\n    if (ua.indexOf(\"Win\") !== -1) os = \"Windows\";\n    else if (ua.indexOf(\"Mac\") !== -1) os = \"MacOS\";\n    else if (ua.indexOf(\"Linux\") !== -1) os = \"Linux\";\n    else if (/Android/i.test(ua)) os = \"Android\";\n    else if (/iPhone|iPad|iPod/i.test(ua)) os = \"iOS\";\n    if (ua.indexOf(\"Chrome\") !== -1) browser = \"Chrome\";\n    else if (ua.indexOf(\"Safari\") !== -1 && ua.indexOf(\"Chrome\") === -1) browser = \"Safari\";\n    else if (ua.indexOf(\"Firefox\") !== -1) browser = \"Firefox\";\n    else if (ua.indexOf(\"Edg\") !== -1) browser = \"Edge\";\n    // ðŸ”’ No exponer userAgent completo, solo hash\n    const uaHash = crypto.subtle ? hashString(ua) : \"legacy\";\n    return {\n        os,\n        browser,\n        uaHash\n    };\n}\n// Hash simple para userAgent\nfunction hashString(str) {\n    let hash = 0;\n    for(let i = 0; i < str.length; i++){\n        const char = str.charCodeAt(i);\n        hash = (hash << 5) - hash + char;\n        hash = hash & hash;\n    }\n    return Math.abs(hash).toString(36);\n}\nasync function getOrCreateDeviceId() {\n    // Buscar en la cache\n    let cache = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.auth.get(\"device\");\n    if (cache === null || cache === void 0 ? void 0 : cache.deviceId) {\n        return cache.deviceId; // âœ… ya existe, lo reutilizamos\n    }\n    try {\n        // Generar por primera vez\n        const info = getDeviceInfo();\n        const newId = {\n            uuid: crypto.randomUUID(),\n            os: info.os,\n            browser: info.browser,\n            uaHash: info.uaHash,\n            createdAt: new Date().toISOString()\n        };\n        const deviceIdStr = JSON.stringify(newId);\n        const deviceId = JSON.parse(deviceIdStr);\n        // Guardamos en IndexedDB en un registro separado \"device\"\n        await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.devices.put({\n            id: \"device\",\n            deviceId\n        });\n        return deviceId;\n    } catch (e) {\n        console.log(\"Error al crear DeviceId en auth.ts \", e);\n    }\n    return \"\";\n}\n/** ðŸ”¹ Guardar tokens en IndexedDB */ async function saveTokens(tokens) {\n    await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.tokens.put(tokens);\n}\n/** ðŸ”¹ Leer tokens de IndexedDB */ async function getTokens() {\n    const record = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.tokens.get(TOKEN_KEY);\n    if (!record) return null;\n    var _record_refreshToken;\n    return {\n        id: TOKEN_KEY,\n        accessToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.decryptData)(record.accessToken),\n        refreshToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.decryptData)((_record_refreshToken = record.refreshToken) !== null && _record_refreshToken !== void 0 ? _record_refreshToken : \"\"),\n        expiresAt: record.expiresAt,\n        usuarioConfiguracion: record.usuarioConfiguracion\n    };\n}\n/** ðŸ”¹ Borrar tokens â†’ logout */ async function clearTokens() {\n    await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.auth.delete(TOKEN_KEY);\n    await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.tokens.delete(TOKEN_KEY);\n}\n/** ðŸ”¹ Refrescar token */ async function refreshToken(refreshToken) {\n    let retries = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 3;\n    try {\n        const res = await fetch(\"\".concat(API_BASE, \"/auth/refresh\"), {\n            method: \"POST\",\n            headers: {\n                Authorization: \"Bearer \".concat(refreshToken)\n            }\n        });\n        const data = await res.json();\n        if (!res.ok) {\n            // ðŸ”’ Seguridad: Si el refresh falla, limpiar sesiÃ³n\n            if (res.status === 401 || res.status === 403) {\n                await clearTokens();\n                throw new Error(\"SesiÃ³n expirada. Por favor, inicia sesiÃ³n nuevamente.\");\n            }\n            throw new Error(\"Error al refrescar token: \" + JSON.stringify(data));\n        }\n        const expiresIn = 15 * 60 * 1000;\n        const tokens = {\n            id: TOKEN_KEY,\n            accessToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.encryptData)(data.accessToken),\n            refreshToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.encryptData)(data.refreshToken),\n            expiresAt: Date.now() + expiresIn,\n            usuarioConfiguracion: data.usuarioConfiguracionList\n        };\n        await saveTokens(tokens);\n        var _tokens_refreshToken;\n        return {\n            id: TOKEN_KEY,\n            accessToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.decryptData)(tokens.accessToken),\n            refreshToken: await (0,_lib_crypto_utils__WEBPACK_IMPORTED_MODULE_1__.decryptData)((_tokens_refreshToken = tokens.refreshToken) !== null && _tokens_refreshToken !== void 0 ? _tokens_refreshToken : \"\"),\n            expiresAt: tokens.expiresAt,\n            usuarioConfiguracion: tokens.usuarioConfiguracion\n        };\n    } catch (error) {\n        // ðŸ”’ Retry logic para errores de red\n        if (retries > 0 && !(error instanceof Error && error.message.includes(\"SesiÃ³n expirada\"))) {\n            console.warn(\"Reintentando refresh token... (intentos restantes: \".concat(retries, \")\"));\n            await new Promise((resolve)=>setTimeout(resolve, 1000));\n            return refreshToken(refreshToken, retries - 1);\n        }\n        throw error;\n    }\n}\n/** ðŸ”¹ Obtener accessToken vÃ¡lido (renueva si expirÃ³) */ async function getAccessToken() {\n    let tokens = await getTokens();\n    if (!tokens) {\n        throw new Error(\"No hay sesiÃ³n activa\");\n    }\n    if (Date.now() >= tokens.expiresAt) {\n        tokens = await refreshToken(tokens.refreshToken);\n    }\n    return tokens.accessToken;\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QyxjQUFhLE1BQU12RCw4REFBV0EsQ0FBQ2tFLEtBQUtYLFlBQVk7WUFDaERDLFdBQVdsQixLQUFLa0MsR0FBRyxLQUFLRDtZQUN4QmQsc0JBQXNCUyxLQUFLTyx3QkFBd0I7UUFDckQ7UUFFQSxNQUFNdkIsV0FBV0M7WUFJaUJBO1FBSGxDLE9BQU87WUFDTEwsSUFBRzVDO1lBQ0hvRCxhQUFhLE1BQU1yRCw4REFBV0EsQ0FBQ2tELE9BQU9HLFdBQVc7WUFDakRDLGNBQWMsTUFBTXRELDhEQUFXQSxDQUFDa0QsQ0FBQUEsdUJBQUFBLE9BQU9JLFlBQVksY0FBbkJKLGtDQUFBQSx1QkFBdUI7WUFDdkRLLFdBQVdMLE9BQU9LLFNBQVM7WUFDM0JDLHNCQUFzQk4sT0FBT00sb0JBQW9CO1FBQ25EO0lBQ0YsRUFBRSxPQUFPaUIsT0FBTztRQUNkLHFDQUFxQztRQUNyQyxJQUFJZCxVQUFVLEtBQUssQ0FBRWMsQ0FBQUEsaUJBQWlCSixTQUFTSSxNQUFNQyxPQUFPLENBQUNDLFFBQVEsQ0FBQyxrQkFBaUIsR0FBSTtZQUN6RjVCLFFBQVE2QixJQUFJLENBQUMsc0RBQThELE9BQVJqQixTQUFRO1lBQzNFLE1BQU0sSUFBSWtCLFFBQVFDLENBQUFBLFVBQVdDLFdBQVdELFNBQVM7WUFDakQsT0FBT3hCLGFBQWFBLGNBQWNLLFVBQVU7UUFDOUM7UUFDQSxNQUFNYztJQUNSO0FBQ0Y7QUFFQSxzREFBc0QsR0FDL0MsZUFBZU87SUFDcEIsSUFBSTlCLFNBQVMsTUFBTUM7SUFDbkIsSUFBSSxDQUFDRCxRQUFRO1FBQ1gsTUFBTSxJQUFJbUIsTUFBTTtJQUNsQjtJQUVBLElBQUloQyxLQUFLa0MsR0FBRyxNQUFNckIsT0FBT0ssU0FBUyxFQUFFO1FBQ2xDTCxTQUFTLE1BQU1JLGFBQWFKLE9BQU9JLFlBQVk7SUFDakQ7SUFFQSxPQUFPSixPQUFPRyxXQUFXO0FBQzNCIiwic291cmNlcyI6WyJDOlxcZGVzYXJyb2xsb19yZWFjdFxccHJldmVudGFcXHNvZnR3YXJlLWNvbWVyY2lhbFxcc2VydmljZXNcXGF1dGgudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZGIgfSBmcm9tIFwiLi4vbGliL2RiXCI7XHJcbmltcG9ydCB7IGVuY3J5cHREYXRhLCBkZWNyeXB0RGF0YSB9IGZyb20gXCIuLi9saWIvY3J5cHRvLXV0aWxzXCI7XHJcbmltcG9ydCB7IFRva2VucyB9IGZyb20gXCIuLi9saWIvdHlwZXNcIjtcclxuXHJcbmNvbnN0IFRPS0VOX0tFWSA9IFwic2Vzc2lvblwiOyAvLyBjbGF2ZSBmaWphIGVuIEluZGV4ZWREQlxyXG5jb25zdCBBUElfQkFTRSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkw7XHJcblxyXG4vLyDwn5SSIFNlZ3VyaWRhZDogTGltaXRhciBpbmZvcm1hY2nDs24gZXhwdWVzdGEgZGVsIGRpc3Bvc2l0aXZvXHJcbmZ1bmN0aW9uIGdldERldmljZUluZm8oKSB7XHJcbiAgY29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xyXG4gIGxldCBvcyA9IFwiVW5rbm93blwiO1xyXG4gIGxldCBicm93c2VyID0gXCJVbmtub3duXCI7XHJcblxyXG4gIGlmICh1YS5pbmRleE9mKFwiV2luXCIpICE9PSAtMSkgb3MgPSBcIldpbmRvd3NcIjtcclxuICBlbHNlIGlmICh1YS5pbmRleE9mKFwiTWFjXCIpICE9PSAtMSkgb3MgPSBcIk1hY09TXCI7XHJcbiAgZWxzZSBpZiAodWEuaW5kZXhPZihcIkxpbnV4XCIpICE9PSAtMSkgb3MgPSBcIkxpbnV4XCI7XHJcbiAgZWxzZSBpZiAoL0FuZHJvaWQvaS50ZXN0KHVhKSkgb3MgPSBcIkFuZHJvaWRcIjtcclxuICBlbHNlIGlmICgvaVBob25lfGlQYWR8aVBvZC9pLnRlc3QodWEpKSBvcyA9IFwiaU9TXCI7XHJcblxyXG4gIGlmICh1YS5pbmRleE9mKFwiQ2hyb21lXCIpICE9PSAtMSkgYnJvd3NlciA9IFwiQ2hyb21lXCI7XHJcbiAgZWxzZSBpZiAodWEuaW5kZXhPZihcIlNhZmFyaVwiKSAhPT0gLTEgJiYgdWEuaW5kZXhPZihcIkNocm9tZVwiKSA9PT0gLTEpIGJyb3dzZXIgPSBcIlNhZmFyaVwiO1xyXG4gIGVsc2UgaWYgKHVhLmluZGV4T2YoXCJGaXJlZm94XCIpICE9PSAtMSkgYnJvd3NlciA9IFwiRmlyZWZveFwiO1xyXG4gIGVsc2UgaWYgKHVhLmluZGV4T2YoXCJFZGdcIikgIT09IC0xKSBicm93c2VyID0gXCJFZGdlXCI7XHJcblxyXG4gIC8vIPCflJIgTm8gZXhwb25lciB1c2VyQWdlbnQgY29tcGxldG8sIHNvbG8gaGFzaFxyXG4gIGNvbnN0IHVhSGFzaCA9IGNyeXB0by5zdWJ0bGUgPyBoYXNoU3RyaW5nKHVhKSA6IFwibGVnYWN5XCI7XHJcbiAgcmV0dXJuIHsgb3MsIGJyb3dzZXIsIHVhSGFzaCB9O1xyXG59XHJcblxyXG4vLyBIYXNoIHNpbXBsZSBwYXJhIHVzZXJBZ2VudFxyXG5mdW5jdGlvbiBoYXNoU3RyaW5nKHN0cjogc3RyaW5nKTogc3RyaW5nIHtcclxuICBsZXQgaGFzaCA9IDA7XHJcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcclxuICAgIGNvbnN0IGNoYXIgPSBzdHIuY2hhckNvZGVBdChpKTtcclxuICAgIGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIGNoYXI7XHJcbiAgICBoYXNoID0gaGFzaCAmIGhhc2g7XHJcbiAgfVxyXG4gIHJldHVybiBNYXRoLmFicyhoYXNoKS50b1N0cmluZygzNik7XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRPckNyZWF0ZURldmljZUlkKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgLy8gQnVzY2FyIGVuIGxhIGNhY2hlXHJcbiAgbGV0IGNhY2hlID0gYXdhaXQgZGIuYXV0aC5nZXQoXCJkZXZpY2VcIik7XHJcbiAgaWYgKGNhY2hlPy5kZXZpY2VJZCkge1xyXG4gICAgcmV0dXJuIGNhY2hlLmRldmljZUlkOyAvLyDinIUgeWEgZXhpc3RlLCBsbyByZXV0aWxpemFtb3NcclxuICB9XHJcbiAgdHJ5e1xyXG4gICAgLy8gR2VuZXJhciBwb3IgcHJpbWVyYSB2ZXpcclxuICAgIGNvbnN0IGluZm8gPSBnZXREZXZpY2VJbmZvKCk7XHJcbiAgICBjb25zdCBuZXdJZCA9IHtcclxuICAgICAgdXVpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgb3M6IGluZm8ub3MsXHJcbiAgICAgIGJyb3dzZXI6IGluZm8uYnJvd3NlcixcclxuICAgICAgdWFIYXNoOiBpbmZvLnVhSGFzaCwgLy8g8J+UkiBTb2xvIGhhc2gsIG5vIHVzZXJBZ2VudCBjb21wbGV0b1xyXG4gICAgICBjcmVhdGVkQXQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgZGV2aWNlSWRTdHIgPSBKU09OLnN0cmluZ2lmeShuZXdJZCk7XHJcbiAgICBjb25zdCBkZXZpY2VJZCA9IEpTT04ucGFyc2UoZGV2aWNlSWRTdHIpO1xyXG4gICAgLy8gR3VhcmRhbW9zIGVuIEluZGV4ZWREQiBlbiB1biByZWdpc3RybyBzZXBhcmFkbyBcImRldmljZVwiXHJcbiAgICAgIGF3YWl0IGRiLmRldmljZXMucHV0KHtcclxuICAgICAgICBpZDogXCJkZXZpY2VcIixcclxuICAgICAgICBkZXZpY2VJZCxcclxuICAgICAgfSk7XHJcbiAgICByZXR1cm4gZGV2aWNlSWQ7XHJcbiAgfWNhdGNoKGUpe1xyXG4gICAgY29uc29sZS5sb2coXCJFcnJvciBhbCBjcmVhciBEZXZpY2VJZCBlbiBhdXRoLnRzIFwiLGUpO1xyXG4gIH1cclxuICByZXR1cm4gXCJcIjtcclxufVxyXG5cclxuLyoqIPCflLkgR3VhcmRhciB0b2tlbnMgZW4gSW5kZXhlZERCICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzYXZlVG9rZW5zKHRva2VuczogVG9rZW5zKTogUHJvbWlzZTx2b2lkPiB7XHJcbiAgYXdhaXQgZGIudG9rZW5zLnB1dCh0b2tlbnMpO1xyXG59XHJcblxyXG5cclxuLyoqIPCflLkgTGVlciB0b2tlbnMgZGUgSW5kZXhlZERCICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRUb2tlbnMoKTogUHJvbWlzZTxUb2tlbnMgfCBudWxsPiB7XHJcbiAgY29uc3QgcmVjb3JkID0gYXdhaXQgZGIudG9rZW5zLmdldChUT0tFTl9LRVkpO1xyXG4gIGlmICghcmVjb3JkKSByZXR1cm4gbnVsbDtcclxuICByZXR1cm4ge1xyXG4gICAgaWQ6VE9LRU5fS0VZLFxyXG4gICAgYWNjZXNzVG9rZW46IGF3YWl0IGRlY3J5cHREYXRhKHJlY29yZC5hY2Nlc3NUb2tlbiksXHJcbiAgICByZWZyZXNoVG9rZW46IGF3YWl0IGRlY3J5cHREYXRhKHJlY29yZC5yZWZyZXNoVG9rZW4gPz8gXCJcIiksIC8vIPCfkYggZmFsbGJhY2sgc3RyaW5nIHZhY8Otb1xyXG4gICAgZXhwaXJlc0F0OiByZWNvcmQuZXhwaXJlc0F0LFxyXG4gICAgdXN1YXJpb0NvbmZpZ3VyYWNpb246IHJlY29yZC51c3VhcmlvQ29uZmlndXJhY2lvbixcclxuICB9O1xyXG59XHJcblxyXG4vKiog8J+UuSBCb3JyYXIgdG9rZW5zIOKGkiBsb2dvdXQgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGNsZWFyVG9rZW5zKCkge1xyXG4gIGF3YWl0IGRiLmF1dGguZGVsZXRlKFRPS0VOX0tFWSk7XHJcbiAgYXdhaXQgZGIudG9rZW5zLmRlbGV0ZShUT0tFTl9LRVkpO1xyXG59XHJcblxyXG4vKiog8J+UuSBSZWZyZXNjYXIgdG9rZW4gKi9cclxuYXN5bmMgZnVuY3Rpb24gcmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbjogc3RyaW5nLCByZXRyaWVzID0gMyk6IFByb21pc2U8VG9rZW5zPiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9hdXRoL3JlZnJlc2hgLCB7XHJcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXHJcbiAgICAgIGhlYWRlcnM6IHsgQXV0aG9yaXphdGlvbjogYEJlYXJlciAke3JlZnJlc2hUb2tlbn1gIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcmVzLmpzb24oKTtcclxuICAgIFxyXG4gICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgLy8g8J+UkiBTZWd1cmlkYWQ6IFNpIGVsIHJlZnJlc2ggZmFsbGEsIGxpbXBpYXIgc2VzacOzblxyXG4gICAgICBpZiAocmVzLnN0YXR1cyA9PT0gNDAxIHx8IHJlcy5zdGF0dXMgPT09IDQwMykge1xyXG4gICAgICAgIGF3YWl0IGNsZWFyVG9rZW5zKCk7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU2VzacOzbiBleHBpcmFkYS4gUG9yIGZhdm9yLCBpbmljaWEgc2VzacOzbiBudWV2YW1lbnRlLlwiKTtcclxuICAgICAgfVxyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFcnJvciBhbCByZWZyZXNjYXIgdG9rZW46IFwiICsgSlNPTi5zdHJpbmdpZnkoZGF0YSkpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGV4cGlyZXNJbiA9IDE1ICogNjAgKiAxMDAwO1xyXG5cclxuICAgIGNvbnN0IHRva2VuczogVG9rZW5zID0ge1xyXG4gICAgICBpZDpUT0tFTl9LRVksXHJcbiAgICAgIGFjY2Vzc1Rva2VuOiBhd2FpdCBlbmNyeXB0RGF0YShkYXRhLmFjY2Vzc1Rva2VuKSwgXHJcbiAgICAgIHJlZnJlc2hUb2tlbjphd2FpdCBlbmNyeXB0RGF0YShkYXRhLnJlZnJlc2hUb2tlbiksXHJcbiAgICAgIGV4cGlyZXNBdDogRGF0ZS5ub3coKSArIGV4cGlyZXNJbixcclxuICAgICAgdXN1YXJpb0NvbmZpZ3VyYWNpb246IGRhdGEudXN1YXJpb0NvbmZpZ3VyYWNpb25MaXN0XHJcbiAgICB9O1xyXG5cclxuICAgIGF3YWl0IHNhdmVUb2tlbnModG9rZW5zKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOlRPS0VOX0tFWSxcclxuICAgICAgYWNjZXNzVG9rZW46IGF3YWl0IGRlY3J5cHREYXRhKHRva2Vucy5hY2Nlc3NUb2tlbiksXHJcbiAgICAgIHJlZnJlc2hUb2tlbjogYXdhaXQgZGVjcnlwdERhdGEodG9rZW5zLnJlZnJlc2hUb2tlbiA/PyBcIlwiKSwgLy8g8J+RiCBmYWxsYmFjayBzdHJpbmcgdmFjw61vXHJcbiAgICAgIGV4cGlyZXNBdDogdG9rZW5zLmV4cGlyZXNBdCxcclxuICAgICAgdXN1YXJpb0NvbmZpZ3VyYWNpb246IHRva2Vucy51c3VhcmlvQ29uZmlndXJhY2lvbixcclxuICAgIH07XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIC8vIPCflJIgUmV0cnkgbG9naWMgcGFyYSBlcnJvcmVzIGRlIHJlZFxyXG4gICAgaWYgKHJldHJpZXMgPiAwICYmICEoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5tZXNzYWdlLmluY2x1ZGVzKFwiU2VzacOzbiBleHBpcmFkYVwiKSkpIHtcclxuICAgICAgY29uc29sZS53YXJuKGBSZWludGVudGFuZG8gcmVmcmVzaCB0b2tlbi4uLiAoaW50ZW50b3MgcmVzdGFudGVzOiAke3JldHJpZXN9KWApO1xyXG4gICAgICBhd2FpdCBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgMTAwMCkpO1xyXG4gICAgICByZXR1cm4gcmVmcmVzaFRva2VuKHJlZnJlc2hUb2tlbiwgcmV0cmllcyAtIDEpO1xyXG4gICAgfVxyXG4gICAgdGhyb3cgZXJyb3I7XHJcbiAgfVxyXG59XHJcblxyXG4vKiog8J+UuSBPYnRlbmVyIGFjY2Vzc1Rva2VuIHbDoWxpZG8gKHJlbnVldmEgc2kgZXhwaXLDsykgKi9cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEFjY2Vzc1Rva2VuKCk6IFByb21pc2U8c3RyaW5nPiB7XHJcbiAgbGV0IHRva2VucyA9IGF3YWl0IGdldFRva2VucygpO1xyXG4gIGlmICghdG9rZW5zKSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBoYXkgc2VzacOzbiBhY3RpdmFcIik7XHJcbiAgfVxyXG5cclxuICBpZiAoRGF0ZS5ub3coKSA+PSB0b2tlbnMuZXhwaXJlc0F0KSB7XHJcbiAgICB0b2tlbnMgPSBhd2FpdCByZWZyZXNoVG9rZW4odG9rZW5zLnJlZnJlc2hUb2tlbik7XHJcbiAgfVxyXG5cclxuICByZXR1cm4gdG9rZW5zLmFjY2Vzc1Rva2VuO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJkYiIsImVuY3J5cHREYXRhIiwiZGVjcnlwdERhdGEiLCJUT0tFTl9LRVkiLCJBUElfQkFTRSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwiZ2V0RGV2aWNlSW5mbyIsInVhIiwibmF2aWdhdG9yIiwidXNlckFnZW50Iiwib3MiLCJicm93c2VyIiwiaW5kZXhPZiIsInRlc3QiLCJ1YUhhc2giLCJjcnlwdG8iLCJzdWJ0bGUiLCJoYXNoU3RyaW5nIiwic3RyIiwiaGFzaCIsImkiLCJsZW5ndGgiLCJjaGFyIiwiY2hhckNvZGVBdCIsIk1hdGgiLCJhYnMiLCJ0b1N0cmluZyIsImdldE9yQ3JlYXRlRGV2aWNlSWQiLCJjYWNoZSIsImF1dGgiLCJnZXQiLCJkZXZpY2VJZCIsImluZm8iLCJuZXdJZCIsInV1aWQiLCJyYW5kb21VVUlEIiwiY3JlYXRlZEF0IiwiRGF0ZSIsInRvSVNPU3RyaW5nIiwiZGV2aWNlSWRTdHIiLCJKU09OIiwic3RyaW5naWZ5IiwicGFyc2UiLCJkZXZpY2VzIiwicHV0IiwiaWQiLCJlIiwiY29uc29sZSIsImxvZyIsInNhdmVUb2tlbnMiLCJ0b2tlbnMiLCJnZXRUb2tlbnMiLCJyZWNvcmQiLCJhY2Nlc3NUb2tlbiIsInJlZnJlc2hUb2tlbiIsImV4cGlyZXNBdCIsInVzdWFyaW9Db25maWd1cmFjaW9uIiwiY2xlYXJUb2tlbnMiLCJkZWxldGUiLCJyZXRyaWVzIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiQXV0aG9yaXphdGlvbiIsImRhdGEiLCJqc29uIiwib2siLCJzdGF0dXMiLCJFcnJvciIsImV4cGlyZXNJbiIsIm5vdyIsInVzdWFyaW9Db25maWd1cmFjaW9uTGlzdCIsImVycm9yIiwibWVzc2FnZSIsImluY2x1ZGVzIiwid2FybiIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsImdldEFjY2Vzc1Rva2VuIl0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/auth.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/authService.ts":
/*!*********************************!*\
  !*** ./services/authService.ts ***!
  \*********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   loginService: () => (/* binding */ loginService)\n/* harmony export */ });\nconst API_BASE = \"https://plugins-indicators-charitable-subtle.trycloudflare.com\";\nasync function loginService(username, password, deviceId) {\n    const res = await fetch(\"\".concat(API_BASE, \"/auth/login\"), {\n        method: \"POST\",\n        headers: {\n            \"Content-Type\": \"application/json\"\n        },\n        body: JSON.stringify({\n            username,\n            password,\n            deviceId\n        })\n    });\n    if (!res.ok) return null;\n    return res.json(); // { token: \"...\" }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL2F1dGhTZXJ2aWNlLnRzIiwibWFwcGluZ3MiOiI7Ozs7QUFDQSxNQUFNQSxXQUFXQyxnRUFBK0I7QUFHekMsZUFBZUcsYUFBYUMsUUFBZ0IsRUFBRUMsUUFBZ0IsRUFBRUMsUUFBZ0I7SUFDckYsTUFBTUMsTUFBTSxNQUFNQyxNQUFNLEdBQVksT0FBVFQsVUFBUyxnQkFBYztRQUNoRFUsUUFBUTtRQUNSQyxTQUFTO1lBQUUsZ0JBQWdCO1FBQW1CO1FBQzlDQyxNQUFNQyxLQUFLQyxTQUFTLENBQUM7WUFBRVQ7WUFBVUM7WUFBVUM7UUFBUztJQUN0RDtJQUNBLElBQUksQ0FBQ0MsSUFBSU8sRUFBRSxFQUFFLE9BQU87SUFDcEIsT0FBT1AsSUFBSVEsSUFBSSxJQUFJLG1CQUFtQjtBQUN4QyIsInNvdXJjZXMiOlsiQzpcXGRlc2Fycm9sbG9fcmVhY3RcXHByZXZlbnRhXFxzb2Z0d2FyZS1jb21lcmNpYWxcXHNlcnZpY2VzXFxhdXRoU2VydmljZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJcclxuY29uc3QgQVBJX0JBU0UgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMO1xyXG5cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBsb2dpblNlcnZpY2UodXNlcm5hbWU6IHN0cmluZywgcGFzc3dvcmQ6IHN0cmluZywgZGV2aWNlSWQ6IHN0cmluZykge1xyXG4gIGNvbnN0IHJlcyA9IGF3YWl0IGZldGNoKGAke0FQSV9CQVNFfS9hdXRoL2xvZ2luYCwge1xyXG4gICAgbWV0aG9kOiBcIlBPU1RcIixcclxuICAgIGhlYWRlcnM6IHsgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfSxcclxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgdXNlcm5hbWUsIHBhc3N3b3JkLCBkZXZpY2VJZCB9KSxcclxuICB9KTtcclxuICBpZiAoIXJlcy5vaykgcmV0dXJuIG51bGw7XHJcbiAgcmV0dXJuIHJlcy5qc29uKCk7IC8vIHsgdG9rZW46IFwiLi4uXCIgfVxyXG59XHJcbiJdLCJuYW1lcyI6WyJBUElfQkFTRSIsInByb2Nlc3MiLCJlbnYiLCJORVhUX1BVQkxJQ19BUElfVVJMIiwibG9naW5TZXJ2aWNlIiwidXNlcm5hbWUiLCJwYXNzd29yZCIsImRldmljZUlkIiwicmVzIiwiZmV0Y2giLCJtZXRob2QiLCJoZWFkZXJzIiwiYm9keSIsIkpTT04iLCJzdHJpbmdpZnkiLCJvayIsImpzb24iXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/authService.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/orders.ts":
/*!****************************!*\
  !*** ./services/orders.ts ***!
  \****************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCachedOrders: () => (/* binding */ getCachedOrders),\n/* harmony export */   syncOrderToServer: () => (/* binding */ syncOrderToServer)\n/* harmony export */ });\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/db */ \"(app-pages-browser)/./lib/db.ts\");\n// services/orders.ts\n\nconst API = \"https://plugins-indicators-charitable-subtle.trycloudflare.com\" || 0; // ej. https://api.tu-backend.com\nasync function getCachedOrders() {\n    try {\n        return await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.orders.toArray();\n    } catch (e) {\n        return [];\n    }\n}\n// Si tienes un getAccessToken() Ãºsalo aquÃ­. Por ahora omitimos token para no romper\nasync function getAccessTokenSafe() {\n    try {\n        const row = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.tokens.get(\"tokens\");\n        var _row_accessToken;\n        return (_row_accessToken = row === null || row === void 0 ? void 0 : row.accessToken) !== null && _row_accessToken !== void 0 ? _row_accessToken : null;\n    } catch (e) {\n        return null;\n    }\n}\nasync function syncOrderToServer(order) {\n    try {\n        var _order_items;\n        const token = await getAccessTokenSafe();\n        var _order_notes;\n        // ðŸ”’ Seguridad: Limitar longitud de notas\n        const sanitizedNotes = ((_order_notes = order.notes) !== null && _order_notes !== void 0 ? _order_notes : \"\").substring(0, 500);\n        var _order_discount, _order_photos, _order_location;\n        // Mapea si tu backend requiere otra forma\n        const payload = {\n            localId: order.localId,\n            customerId: order.customerId,\n            discount: Math.max(0, Math.min(100, (_order_discount = order.discount) !== null && _order_discount !== void 0 ? _order_discount : 0)),\n            total: order.total,\n            createdAt: order.createdAt,\n            items: (_order_items = order.items) === null || _order_items === void 0 ? void 0 : _order_items.map((it)=>{\n                var _it_priceSource, _it_comboId, _it_kitId;\n                return {\n                    productoId: it.productoId,\n                    descripcion: it.descripcion.substring(0, 200),\n                    cantidad: Math.max(0, it.cantidad),\n                    precioUnitario: Math.max(0, it.precioUnitario),\n                    subtotal: Math.max(0, it.subtotal),\n                    priceSource: (_it_priceSource = it.priceSource) !== null && _it_priceSource !== void 0 ? _it_priceSource : \"base\",\n                    comboId: (_it_comboId = it.comboId) !== null && _it_comboId !== void 0 ? _it_comboId : null,\n                    kitId: (_it_kitId = it.kitId) !== null && _it_kitId !== void 0 ? _it_kitId : null\n                };\n            }),\n            notes: sanitizedNotes,\n            photos: ((_order_photos = order.photos) !== null && _order_photos !== void 0 ? _order_photos : []).slice(0, 10),\n            location: (_order_location = order.location) !== null && _order_location !== void 0 ? _order_location : null\n        };\n        // ðŸ”’ Seguridad: Timeout de 30 segundos\n        const controller = new AbortController();\n        const timeoutId = setTimeout(()=>controller.abort(), 30000);\n        const res = await fetch(\"\".concat(API, \"/pedidos\"), {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...token ? {\n                    Authorization: \"Bearer \".concat(token)\n                } : {},\n                \"Idempotency-Key\": order.localId\n            },\n            body: JSON.stringify(payload),\n            signal: controller.signal\n        });\n        clearTimeout(timeoutId);\n        if (!res.ok) {\n            const txt = await res.text().catch(()=>\"\");\n            return {\n                ok: false,\n                error: \"\".concat(res.status, \" \").concat(txt)\n            };\n        }\n        const data = await res.json().catch(()=>({}));\n        var _data_id, _ref;\n        return {\n            ok: true,\n            serverId: (_ref = (_data_id = data === null || data === void 0 ? void 0 : data.id) !== null && _data_id !== void 0 ? _data_id : data === null || data === void 0 ? void 0 : data.serverId) !== null && _ref !== void 0 ? _ref : null\n        };\n    } catch (e) {\n        // ðŸ”’ Seguridad: Detectar timeout\n        if ((e === null || e === void 0 ? void 0 : e.name) === 'AbortError') {\n            return {\n                ok: false,\n                error: \"Timeout: La peticiÃ³n tardÃ³ mÃ¡s de 30 segundos\"\n            };\n        }\n        var _e_message;\n        return {\n            ok: false,\n            error: (_e_message = e === null || e === void 0 ? void 0 : e.message) !== null && _e_message !== void 0 ? _e_message : \"Network error\"\n        };\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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O1lBQ0FnQyxNQUFNQyxLQUFLQyxTQUFTLENBQUNuQztZQUNyQm9DLFFBQVFiLFdBQVdhLE1BQU07UUFDM0I7UUFDQUMsYUFBYVo7UUFFYixJQUFJLENBQUNHLElBQUlVLEVBQUUsRUFBRTtZQUNYLE1BQU1DLE1BQU0sTUFBTVgsSUFBSVksSUFBSSxHQUFHQyxLQUFLLENBQUMsSUFBTTtZQUN6QyxPQUFPO2dCQUFFSCxJQUFJO2dCQUFPSSxPQUFPLEdBQWlCSCxPQUFkWCxJQUFJZSxNQUFNLEVBQUMsS0FBTyxPQUFKSjtZQUFNO1FBQ3BEO1FBRUEsTUFBTUssT0FBTyxNQUFNaEIsSUFBSWlCLElBQUksR0FBR0osS0FBSyxDQUFDLElBQU8sRUFBQztZQUNmRyxVQUFBQTtRQUE3QixPQUFPO1lBQUVOLElBQUk7WUFBTVEsVUFBVUYsQ0FBQUEsT0FBQUEsQ0FBQUEsV0FBQUEsaUJBQUFBLDJCQUFBQSxLQUFNRyxFQUFFLGNBQVJILHNCQUFBQSxXQUFZQSxpQkFBQUEsMkJBQUFBLEtBQU1FLFFBQVEsY0FBMUJGLGtCQUFBQSxPQUE4QjtRQUFLO0lBQ2xFLEVBQUUsT0FBT0ksR0FBUTtRQUNmLGlDQUFpQztRQUNqQyxJQUFJQSxDQUFBQSxjQUFBQSx3QkFBQUEsRUFBR0MsSUFBSSxNQUFLLGNBQWM7WUFDNUIsT0FBTztnQkFBRVgsSUFBSTtnQkFBT0ksT0FBTztZQUFnRDtRQUM3RTtZQUMyQk07UUFBM0IsT0FBTztZQUFFVixJQUFJO1lBQU9JLE9BQU9NLENBQUFBLGFBQUFBLGNBQUFBLHdCQUFBQSxFQUFHRSxPQUFPLGNBQVZGLHdCQUFBQSxhQUFjO1FBQWdCO0lBQzNEO0FBQ0YiLCJzb3VyY2VzIjpbIkM6XFxkZXNhcnJvbGxvX3JlYWN0XFxwcmV2ZW50YVxcc29mdHdhcmUtY29tZXJjaWFsXFxzZXJ2aWNlc1xcb3JkZXJzLnRzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNlcnZpY2VzL29yZGVycy50c1xyXG5pbXBvcnQgeyBkYiB9IGZyb20gXCIuLi9saWIvZGJcIjtcclxuaW1wb3J0IHR5cGUgeyBPcmRlciB9IGZyb20gXCIuLi9saWIvdHlwZXNcIjtcclxuXHJcbmNvbnN0IEFQSSA9IHByb2Nlc3MuZW52Lk5FWFRfUFVCTElDX0FQSV9VUkwgfHwgXCJcIjsgLy8gZWouIGh0dHBzOi8vYXBpLnR1LWJhY2tlbmQuY29tXHJcblxyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGVkT3JkZXJzKCk6IFByb21pc2U8T3JkZXJbXT4ge1xyXG4gIHRyeSB7XHJcbiAgICByZXR1cm4gYXdhaXQgZGIub3JkZXJzLnRvQXJyYXkoKTtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuXHJcbi8vIFNpIHRpZW5lcyB1biBnZXRBY2Nlc3NUb2tlbigpIMO6c2FsbyBhcXXDrS4gUG9yIGFob3JhIG9taXRpbW9zIHRva2VuIHBhcmEgbm8gcm9tcGVyXHJcbmFzeW5jIGZ1bmN0aW9uIGdldEFjY2Vzc1Rva2VuU2FmZSgpOiBQcm9taXNlPHN0cmluZyB8IG51bGw+IHtcclxuICB0cnkge1xyXG4gICAgY29uc3Qgcm93ID0gYXdhaXQgZGIudG9rZW5zLmdldChcInRva2Vuc1wiKTtcclxuICAgIHJldHVybiByb3c/LmFjY2Vzc1Rva2VuID8/IG51bGw7XHJcbiAgfSBjYXRjaCB7XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW5jT3JkZXJUb1NlcnZlcihvcmRlcjogT3JkZXIpOiBQcm9taXNlPHsgb2s6IGJvb2xlYW47IHNlcnZlcklkPzogc3RyaW5nOyBlcnJvcj86IHN0cmluZyB9PiB7XHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHRva2VuID0gYXdhaXQgZ2V0QWNjZXNzVG9rZW5TYWZlKCk7XHJcblxyXG4gICAgLy8g8J+UkiBTZWd1cmlkYWQ6IExpbWl0YXIgbG9uZ2l0dWQgZGUgbm90YXNcclxuICAgIGNvbnN0IHNhbml0aXplZE5vdGVzID0gKG9yZGVyLm5vdGVzID8/IFwiXCIpLnN1YnN0cmluZygwLCA1MDApO1xyXG5cclxuICAgIC8vIE1hcGVhIHNpIHR1IGJhY2tlbmQgcmVxdWllcmUgb3RyYSBmb3JtYVxyXG4gICAgY29uc3QgcGF5bG9hZCA9IHtcclxuICAgICAgbG9jYWxJZDogb3JkZXIubG9jYWxJZCxcclxuICAgICAgY3VzdG9tZXJJZDogb3JkZXIuY3VzdG9tZXJJZCxcclxuICAgICAgZGlzY291bnQ6IE1hdGgubWF4KDAsIE1hdGgubWluKDEwMCwgb3JkZXIuZGlzY291bnQgPz8gMCkpLCAvLyAwLTEwMCVcclxuICAgICAgdG90YWw6IG9yZGVyLnRvdGFsLFxyXG4gICAgICBjcmVhdGVkQXQ6IG9yZGVyLmNyZWF0ZWRBdCxcclxuICAgICAgaXRlbXM6IG9yZGVyLml0ZW1zPy5tYXAoKGl0KSA9PiAoe1xyXG4gICAgICAgIHByb2R1Y3RvSWQ6IGl0LnByb2R1Y3RvSWQsXHJcbiAgICAgICAgZGVzY3JpcGNpb246IGl0LmRlc2NyaXBjaW9uLnN1YnN0cmluZygwLCAyMDApLFxyXG4gICAgICAgIGNhbnRpZGFkOiBNYXRoLm1heCgwLCBpdC5jYW50aWRhZCksXHJcbiAgICAgICAgcHJlY2lvVW5pdGFyaW86IE1hdGgubWF4KDAsIGl0LnByZWNpb1VuaXRhcmlvKSxcclxuICAgICAgICBzdWJ0b3RhbDogTWF0aC5tYXgoMCwgaXQuc3VidG90YWwpLFxyXG4gICAgICAgIHByaWNlU291cmNlOiBpdC5wcmljZVNvdXJjZSA/PyBcImJhc2VcIixcclxuICAgICAgICBjb21ib0lkOiBpdC5jb21ib0lkID8/IG51bGwsXHJcbiAgICAgICAga2l0SWQ6IGl0LmtpdElkID8/IG51bGwsXHJcbiAgICAgIH0pKSxcclxuICAgICAgbm90ZXM6IHNhbml0aXplZE5vdGVzLFxyXG4gICAgICBwaG90b3M6IChvcmRlci5waG90b3MgPz8gW10pLnNsaWNlKDAsIDEwKSwgLy8g8J+UkiBNw6F4aW1vIDEwIGZvdG9zXHJcbiAgICAgIGxvY2F0aW9uOiBvcmRlci5sb2NhdGlvbiA/PyBudWxsLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyDwn5SSIFNlZ3VyaWRhZDogVGltZW91dCBkZSAzMCBzZWd1bmRvc1xyXG4gICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgIGNvbnN0IHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCAzMDAwMCk7XHJcblxyXG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goYCR7QVBJfS9wZWRpZG9zYCwge1xyXG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxyXG4gICAgICBoZWFkZXJzOiB7XHJcbiAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXHJcbiAgICAgICAgLi4uKHRva2VuID8geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCB9IDoge30pLFxyXG4gICAgICAgIFwiSWRlbXBvdGVuY3ktS2V5XCI6IG9yZGVyLmxvY2FsSWQsXHJcbiAgICAgIH0sXHJcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHBheWxvYWQpLFxyXG4gICAgICBzaWduYWw6IGNvbnRyb2xsZXIuc2lnbmFsLFxyXG4gICAgfSk7XHJcbiAgICBjbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuXHJcbiAgICBpZiAoIXJlcy5vaykge1xyXG4gICAgICBjb25zdCB0eHQgPSBhd2FpdCByZXMudGV4dCgpLmNhdGNoKCgpID0+IFwiXCIpO1xyXG4gICAgICByZXR1cm4geyBvazogZmFsc2UsIGVycm9yOiBgJHtyZXMuc3RhdHVzfSAke3R4dH1gIH07XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGF0YSA9IGF3YWl0IHJlcy5qc29uKCkuY2F0Y2goKCkgPT4gKHt9KSk7XHJcbiAgICByZXR1cm4geyBvazogdHJ1ZSwgc2VydmVySWQ6IGRhdGE/LmlkID8/IGRhdGE/LnNlcnZlcklkID8/IG51bGwgfTtcclxuICB9IGNhdGNoIChlOiBhbnkpIHtcclxuICAgIC8vIPCflJIgU2VndXJpZGFkOiBEZXRlY3RhciB0aW1lb3V0XHJcbiAgICBpZiAoZT8ubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XHJcbiAgICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IFwiVGltZW91dDogTGEgcGV0aWNpw7NuIHRhcmTDsyBtw6FzIGRlIDMwIHNlZ3VuZG9zXCIgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7IG9rOiBmYWxzZSwgZXJyb3I6IGU/Lm1lc3NhZ2UgPz8gXCJOZXR3b3JrIGVycm9yXCIgfTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbImRiIiwiQVBJIiwicHJvY2VzcyIsImVudiIsIk5FWFRfUFVCTElDX0FQSV9VUkwiLCJnZXRDYWNoZWRPcmRlcnMiLCJvcmRlcnMiLCJ0b0FycmF5IiwiZ2V0QWNjZXNzVG9rZW5TYWZlIiwicm93IiwidG9rZW5zIiwiZ2V0IiwiYWNjZXNzVG9rZW4iLCJzeW5jT3JkZXJUb1NlcnZlciIsIm9yZGVyIiwidG9rZW4iLCJzYW5pdGl6ZWROb3RlcyIsIm5vdGVzIiwic3Vic3RyaW5nIiwicGF5bG9hZCIsImxvY2FsSWQiLCJjdXN0b21lcklkIiwiZGlzY291bnQiLCJNYXRoIiwibWF4IiwibWluIiwidG90YWwiLCJjcmVhdGVkQXQiLCJpdGVtcyIsIm1hcCIsIml0IiwicHJvZHVjdG9JZCIsImRlc2NyaXBjaW9uIiwiY2FudGlkYWQiLCJwcmVjaW9Vbml0YXJpbyIsInN1YnRvdGFsIiwicHJpY2VTb3VyY2UiLCJjb21ib0lkIiwia2l0SWQiLCJwaG90b3MiLCJzbGljZSIsImxvY2F0aW9uIiwiY29udHJvbGxlciIsIkFib3J0Q29udHJvbGxlciIsInRpbWVvdXRJZCIsInNldFRpbWVvdXQiLCJhYm9ydCIsInJlcyIsImZldGNoIiwibWV0aG9kIiwiaGVhZGVycyIsIkF1dGhvcml6YXRpb24iLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInNpZ25hbCIsImNsZWFyVGltZW91dCIsIm9rIiwidHh0IiwidGV4dCIsImNhdGNoIiwiZXJyb3IiLCJzdGF0dXMiLCJkYXRhIiwianNvbiIsInNlcnZlcklkIiwiaWQiLCJlIiwibmFtZSIsIm1lc3NhZ2UiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/orders.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/products.ts":
/*!******************************!*\
  !*** ./services/products.ts ***!
  \******************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getCachedProducts: () => (/* binding */ getCachedProducts),\n/* harmony export */   getProductsByLine: () => (/* binding */ getProductsByLine),\n/* harmony export */   getProductsByProvider: () => (/* binding */ getProductsByProvider),\n/* harmony export */   searchProducts: () => (/* binding */ searchProducts),\n/* harmony export */   syncProducts: () => (/* binding */ syncProducts)\n/* harmony export */ });\n/* harmony import */ var _lib_db__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../lib/db */ \"(app-pages-browser)/./lib/db.ts\");\n/* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./sync */ \"(app-pages-browser)/./services/sync.ts\");\n/* provided dependency */ var process = __webpack_require__(/*! process */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.2.4_react-dom@19.1.1_react@19.1.1__react@19.1.1/node_modules/next/dist/build/polyfills/process.js\");\n\n\nlet allProducts = [];\nconst API_BASE = \"https://plugins-indicators-charitable-subtle.trycloudflare.com\";\nconst LABEL_PRODUCTOS = process.env.LABEL_PRODUCTOS || \"products\";\nasync function syncProducts(user) {\n    try {\n        const vendedorConf = user === null || user === void 0 ? void 0 : user.usuarioConfiguracion.find((item)=>item.configuracion === \"CODIGO_VENDEDOR\");\n        var _vendedorConf_codigoEmpresa;\n        const codigoEmpresa = (_vendedorConf_codigoEmpresa = vendedorConf === null || vendedorConf === void 0 ? void 0 : vendedorConf.codigoEmpresa) !== null && _vendedorConf_codigoEmpresa !== void 0 ? _vendedorConf_codigoEmpresa : \"\";\n        var _vendedorConf_valor;\n        const codigoVendedor = (_vendedorConf_valor = vendedorConf === null || vendedorConf === void 0 ? void 0 : vendedorConf.valor) !== null && _vendedorConf_valor !== void 0 ? _vendedorConf_valor : \"\";\n        const params = {\n            codigoEmpresa: codigoEmpresa,\n            codigoVendedor: codigoVendedor\n        };\n        const result = await (0,_sync__WEBPACK_IMPORTED_MODULE_1__.syncData)(\"catalogo-productos/porVendedor\", \"Productos\", 20, params);\n        // ðŸ‘‡ si result es null, queda []\n        allProducts = result !== null && result !== void 0 ? result : [];\n        await (0,_lib_db__WEBPACK_IMPORTED_MODULE_0__.saveData)(\"products\", allProducts);\n    } catch (error) {\n        console.error(\"âŒ Error sincronizando productos:\", error);\n    }\n    return allProducts;\n}\n/**\r\n * Devuelve todos los productos cacheados de IndexedDB.\r\n */ async function getCachedProducts() {\n    try {\n        return await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.products.toArray();\n    } catch (e) {\n        return [];\n    }\n}\n/**\r\n * Devuelve productos filtrados por proveedor.\r\n */ async function getProductsByProvider(proveedorId) {\n    return await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.products.where(\"codigoProveedor\").equals(proveedorId).toArray();\n}\n/**\r\n * Devuelve productos filtrados por lÃ­nea.\r\n */ async function getProductsByLine(lineaId) {\n    return await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.products.where(\"codigoSubfamilia\").equals(lineaId).toArray();\n// ðŸ‘† cÃ¡mbialo si tu campo real es `linea_id` en vez de `codigoSubfamilia`\n}\n/**\r\n * Busca productos en cache por texto libre.\r\n */ async function searchProducts(term) {\n    const q = term.toLowerCase();\n    const all = await _lib_db__WEBPACK_IMPORTED_MODULE_0__.db.products.toArray();\n    return all.filter((p)=>[\n            p.descripcion,\n            p.descripcionCorta,\n            p.codigoProducto,\n            p.codigoProducto,\n            p.proveedor,\n            p.codigoFamilia,\n            p.familia,\n            p.codigoSubfamilia,\n            p.subfamilia,\n            p.categoria,\n            p.codigoFiltroVenta,\n            p.filtroVenta,\n            p.urlImg\n        ].join(\" \").toLowerCase().includes(q));\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3Byb2R1Y3RzLnRzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQWtEO0FBRWpCO0FBRWpDLElBQUlHLGNBQXlCLEVBQUU7QUFDL0IsTUFBTUMsV0FBV0MsZ0VBQStCO0FBQ2hELE1BQU1HLGtCQUFrQkgsT0FBT0EsQ0FBQ0MsR0FBRyxDQUFDRSxlQUFlLElBQUk7QUFHaEQsZUFBZUMsYUFBYUMsSUFBcUI7SUFFdEQsSUFBSTtRQUNGLE1BQU1DLGVBQWVELGlCQUFBQSwyQkFBQUEsS0FBTUUsb0JBQW9CLENBQUNDLElBQUksQ0FDbEQsQ0FBQ0MsT0FBY0EsS0FBS0MsYUFBYSxLQUFLO1lBRWxCSjtRQUF0QixNQUFNSyxnQkFBZ0JMLENBQUFBLDhCQUFBQSx5QkFBQUEsbUNBQUFBLGFBQWNLLGFBQWEsY0FBM0JMLHlDQUFBQSw4QkFBNkI7WUFDNUJBO1FBQXZCLE1BQU1NLGlCQUFpQk4sQ0FBQUEsc0JBQUFBLHlCQUFBQSxtQ0FBQUEsYUFBY08sS0FBSyxjQUFuQlAsaUNBQUFBLHNCQUFxQjtRQUM1QyxNQUFNUSxTQUFpQztZQUFHSCxlQUFjQTtZQUFlQyxnQkFBZ0JBO1FBQWU7UUFFdEcsTUFBTUcsU0FBUyxNQUFNbEIsK0NBQVFBLENBQUMsa0NBQWtDLGFBQWEsSUFBSWlCO1FBQ2pGLGlDQUFpQztRQUNqQ2hCLGNBQWVpQixtQkFBQUEsb0JBQUFBLFNBQVUsRUFBRTtRQUMzQixNQUFNcEIsaURBQVFBLENBQUMsWUFBWUc7SUFDN0IsRUFBRSxPQUFPa0IsT0FBTztRQUNkQyxRQUFRRCxLQUFLLENBQUMsb0NBQW9DQTtJQUNwRDtJQUNFLE9BQU9sQjtBQUNYO0FBRUE7O0NBRUMsR0FDTSxlQUFlb0I7SUFDcEIsSUFBSTtRQUNGLE9BQU8sTUFBTXRCLHVDQUFFQSxDQUFDdUIsUUFBUSxDQUFDQyxPQUFPO0lBQ2xDLEVBQUUsVUFBTTtRQUNOLE9BQU8sRUFBRTtJQUNYO0FBQ0Y7QUFFQTs7Q0FFQyxHQUNNLGVBQWVDLHNCQUFzQkMsV0FBbUI7SUFDN0QsT0FBTyxNQUFNMUIsdUNBQUVBLENBQUN1QixRQUFRLENBQUNJLEtBQUssQ0FBQyxtQkFBbUJDLE1BQU0sQ0FBQ0YsYUFBYUYsT0FBTztBQUMvRTtBQUVBOztDQUVDLEdBQ00sZUFBZUssa0JBQWtCQyxPQUFlO0lBQ3JELE9BQU8sTUFBTTlCLHVDQUFFQSxDQUFDdUIsUUFBUSxDQUFDSSxLQUFLLENBQUMsb0JBQW9CQyxNQUFNLENBQUNFLFNBQVNOLE9BQU87QUFDMUUsMEVBQTBFO0FBQzVFO0FBRUE7O0NBRUMsR0FDTSxlQUFlTyxlQUFlQyxJQUFZO0lBQy9DLE1BQU1DLElBQUlELEtBQUtFLFdBQVc7SUFDMUIsTUFBTUMsTUFBTSxNQUFNbkMsdUNBQUVBLENBQUN1QixRQUFRLENBQUNDLE9BQU87SUFDckMsT0FBT1csSUFBSUMsTUFBTSxDQUFDLENBQUNDLElBQ2pCO1lBQ0VBLEVBQUVDLFdBQVc7WUFDYkQsRUFBRUUsZ0JBQWdCO1lBQ2xCRixFQUFFRyxjQUFjO1lBQ2hCSCxFQUFFRyxjQUFjO1lBQ2hCSCxFQUFFSSxTQUFTO1lBQ1hKLEVBQUVLLGFBQWE7WUFDZkwsRUFBRU0sT0FBTztZQUNUTixFQUFFTyxnQkFBZ0I7WUFDbEJQLEVBQUVRLFVBQVU7WUFDWlIsRUFBRVMsU0FBUztZQUNYVCxFQUFFVSxpQkFBaUI7WUFDbkJWLEVBQUVXLFdBQVc7WUFDYlgsRUFBRVksTUFBTTtTQUNULENBQ0VDLElBQUksQ0FBQyxLQUNMaEIsV0FBVyxHQUNYaUIsUUFBUSxDQUFDbEI7QUFFaEIiLCJzb3VyY2VzIjpbIkM6XFxkZXNhcnJvbGxvX3JlYWN0XFxwcmV2ZW50YVxcc29mdHdhcmUtY29tZXJjaWFsXFxzZXJ2aWNlc1xccHJvZHVjdHMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgc2F2ZURhdGEsIGdldERhdGEsIGRiIH0gZnJvbSBcIi4uL2xpYi9kYlwiO1xyXG5pbXBvcnQgdHlwZSB7IFByb2R1Y3QsIEF1dGhVc2VyIH0gZnJvbSBcIi4uL2xpYi90eXBlc1wiO1xyXG5pbXBvcnQgeyBzeW5jRGF0YSB9IGZyb20gXCIuL3N5bmNcIlxyXG5cclxubGV0IGFsbFByb2R1Y3RzOiBQcm9kdWN0W10gPSBbXTtcclxuY29uc3QgQVBJX0JBU0UgPSBwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMO1xyXG5jb25zdCBMQUJFTF9QUk9EVUNUT1MgPSBwcm9jZXNzLmVudi5MQUJFTF9QUk9EVUNUT1MgfHwgXCJwcm9kdWN0c1wiO1xyXG5cclxuXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzeW5jUHJvZHVjdHModXNlcjogQXV0aFVzZXIgfCBudWxsKTogUHJvbWlzZTxQcm9kdWN0W10+IHtcclxuXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHZlbmRlZG9yQ29uZiA9IHVzZXI/LnVzdWFyaW9Db25maWd1cmFjaW9uLmZpbmQoXHJcbiAgICAgIChpdGVtOiBhbnkpID0+IGl0ZW0uY29uZmlndXJhY2lvbiA9PT0gXCJDT0RJR09fVkVOREVET1JcIlxyXG4gICAgKTtcclxuICAgIGNvbnN0IGNvZGlnb0VtcHJlc2EgPSB2ZW5kZWRvckNvbmY/LmNvZGlnb0VtcHJlc2E/P1wiXCI7XHJcbiAgICBjb25zdCBjb2RpZ29WZW5kZWRvciA9IHZlbmRlZG9yQ29uZj8udmFsb3I/P1wiXCI7XHJcbiAgICBjb25zdCBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPSB7ICBjb2RpZ29FbXByZXNhOmNvZGlnb0VtcHJlc2EsIGNvZGlnb1ZlbmRlZG9yOiBjb2RpZ29WZW5kZWRvciB9O1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHN5bmNEYXRhKFwiY2F0YWxvZ28tcHJvZHVjdG9zL3BvclZlbmRlZG9yXCIsIFwiUHJvZHVjdG9zXCIsIDIwLCBwYXJhbXMpXHJcbiAgICAvLyDwn5GHIHNpIHJlc3VsdCBlcyBudWxsLCBxdWVkYSBbXVxyXG4gICAgYWxsUHJvZHVjdHMgPSAocmVzdWx0ID8/IFtdKSBhcyBQcm9kdWN0W11cclxuICAgIGF3YWl0IHNhdmVEYXRhKFwicHJvZHVjdHNcIiwgYWxsUHJvZHVjdHMpO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKFwi4p2MIEVycm9yIHNpbmNyb25pemFuZG8gcHJvZHVjdG9zOlwiLCBlcnJvcilcclxuICB9XHJcbiAgICByZXR1cm4gYWxsUHJvZHVjdHM7XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXZ1ZWx2ZSB0b2RvcyBsb3MgcHJvZHVjdG9zIGNhY2hlYWRvcyBkZSBJbmRleGVkREIuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0Q2FjaGVkUHJvZHVjdHMoKTogUHJvbWlzZTxQcm9kdWN0W10+IHtcclxuICB0cnkge1xyXG4gICAgcmV0dXJuIGF3YWl0IGRiLnByb2R1Y3RzLnRvQXJyYXkoKTtcclxuICB9IGNhdGNoIHtcclxuICAgIHJldHVybiBbXTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBEZXZ1ZWx2ZSBwcm9kdWN0b3MgZmlsdHJhZG9zIHBvciBwcm92ZWVkb3IuXHJcbiAqL1xyXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZ2V0UHJvZHVjdHNCeVByb3ZpZGVyKHByb3ZlZWRvcklkOiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3RbXT4ge1xyXG4gIHJldHVybiBhd2FpdCBkYi5wcm9kdWN0cy53aGVyZShcImNvZGlnb1Byb3ZlZWRvclwiKS5lcXVhbHMocHJvdmVlZG9ySWQpLnRvQXJyYXkoKTtcclxufVxyXG5cclxuLyoqXHJcbiAqIERldnVlbHZlIHByb2R1Y3RvcyBmaWx0cmFkb3MgcG9yIGzDrW5lYS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRQcm9kdWN0c0J5TGluZShsaW5lYUlkOiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3RbXT4ge1xyXG4gIHJldHVybiBhd2FpdCBkYi5wcm9kdWN0cy53aGVyZShcImNvZGlnb1N1YmZhbWlsaWFcIikuZXF1YWxzKGxpbmVhSWQpLnRvQXJyYXkoKTtcclxuICAvLyDwn5GGIGPDoW1iaWFsbyBzaSB0dSBjYW1wbyByZWFsIGVzIGBsaW5lYV9pZGAgZW4gdmV6IGRlIGBjb2RpZ29TdWJmYW1pbGlhYFxyXG59XHJcblxyXG4vKipcclxuICogQnVzY2EgcHJvZHVjdG9zIGVuIGNhY2hlIHBvciB0ZXh0byBsaWJyZS5cclxuICovXHJcbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBzZWFyY2hQcm9kdWN0cyh0ZXJtOiBzdHJpbmcpOiBQcm9taXNlPFByb2R1Y3RbXT4ge1xyXG4gIGNvbnN0IHEgPSB0ZXJtLnRvTG93ZXJDYXNlKCk7XHJcbiAgY29uc3QgYWxsID0gYXdhaXQgZGIucHJvZHVjdHMudG9BcnJheSgpO1xyXG4gIHJldHVybiBhbGwuZmlsdGVyKChwKSA9PlxyXG4gICAgW1xyXG4gICAgICBwLmRlc2NyaXBjaW9uLFxyXG4gICAgICBwLmRlc2NyaXBjaW9uQ29ydGEsXHJcbiAgICAgIHAuY29kaWdvUHJvZHVjdG8sXHJcbiAgICAgIHAuY29kaWdvUHJvZHVjdG8sXHJcbiAgICAgIHAucHJvdmVlZG9yLFxyXG4gICAgICBwLmNvZGlnb0ZhbWlsaWEsXHJcbiAgICAgIHAuZmFtaWxpYSxcclxuICAgICAgcC5jb2RpZ29TdWJmYW1pbGlhLFxyXG4gICAgICBwLnN1YmZhbWlsaWEsXHJcbiAgICAgIHAuY2F0ZWdvcmlhLFxyXG4gICAgICBwLmNvZGlnb0ZpbHRyb1ZlbnRhLFxyXG4gICAgICBwLmZpbHRyb1ZlbnRhLFxyXG4gICAgICBwLnVybEltZyxcclxuICAgIF1cclxuICAgICAgLmpvaW4oXCIgXCIpXHJcbiAgICAgIC50b0xvd2VyQ2FzZSgpXHJcbiAgICAgIC5pbmNsdWRlcyhxKVxyXG4gICk7XHJcbn1cclxuIl0sIm5hbWVzIjpbInNhdmVEYXRhIiwiZGIiLCJzeW5jRGF0YSIsImFsbFByb2R1Y3RzIiwiQVBJX0JBU0UiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsIkxBQkVMX1BST0RVQ1RPUyIsInN5bmNQcm9kdWN0cyIsInVzZXIiLCJ2ZW5kZWRvckNvbmYiLCJ1c3VhcmlvQ29uZmlndXJhY2lvbiIsImZpbmQiLCJpdGVtIiwiY29uZmlndXJhY2lvbiIsImNvZGlnb0VtcHJlc2EiLCJjb2RpZ29WZW5kZWRvciIsInZhbG9yIiwicGFyYW1zIiwicmVzdWx0IiwiZXJyb3IiLCJjb25zb2xlIiwiZ2V0Q2FjaGVkUHJvZHVjdHMiLCJwcm9kdWN0cyIsInRvQXJyYXkiLCJnZXRQcm9kdWN0c0J5UHJvdmlkZXIiLCJwcm92ZWVkb3JJZCIsIndoZXJlIiwiZXF1YWxzIiwiZ2V0UHJvZHVjdHNCeUxpbmUiLCJsaW5lYUlkIiwic2VhcmNoUHJvZHVjdHMiLCJ0ZXJtIiwicSIsInRvTG93ZXJDYXNlIiwiYWxsIiwiZmlsdGVyIiwicCIsImRlc2NyaXBjaW9uIiwiZGVzY3JpcGNpb25Db3J0YSIsImNvZGlnb1Byb2R1Y3RvIiwicHJvdmVlZG9yIiwiY29kaWdvRmFtaWxpYSIsImZhbWlsaWEiLCJjb2RpZ29TdWJmYW1pbGlhIiwic3ViZmFtaWxpYSIsImNhdGVnb3JpYSIsImNvZGlnb0ZpbHRyb1ZlbnRhIiwiZmlsdHJvVmVudGEiLCJ1cmxJbWciLCJqb2luIiwiaW5jbHVkZXMiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/products.ts\n"));

/***/ }),

/***/ "(app-pages-browser)/./services/sync.ts":
/*!**************************!*\
  !*** ./services/sync.ts ***!
  \**************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   syncData: () => (/* binding */ syncData)\n/* harmony export */ });\n/* harmony import */ var _auth__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./auth */ \"(app-pages-browser)/./services/auth.ts\");\n\nasync function syncData(endpoint, label, progress) {\n    let params = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : {};\n    const rawToken = await (0,_auth__WEBPACK_IMPORTED_MODULE_0__.getAccessToken)();\n    const token = rawToken === null || rawToken === void 0 ? void 0 : rawToken.replace(/(\\r\\n|\\n|\\r)/gm, \"\").trim();\n    try {\n        // ðŸ”’ Seguridad: Sanitizar parÃ¡metros\n        const sanitizedParams = {};\n        for (const [key, value] of Object.entries(params)){\n            if (typeof value === 'string') {\n                sanitizedParams[key] = value.substring(0, 200); // limitar longitud\n            } else {\n                sanitizedParams[key] = value;\n            }\n        }\n        // ConstrucciÃ³n de query string\n        let query = \"\";\n        if (Object.keys(sanitizedParams).length > 0) {\n            query = \"?\" + Object.entries(sanitizedParams).map((param)=>{\n                let [key, value] = param;\n                return \"\".concat(key, \"=\").concat(encodeURIComponent(value));\n            }).join(\"&\");\n        }\n        let page = 0;\n        let totalPages = 1;\n        let results = []; // genÃ©rico, puede ser productos, clientes, etc.\n        while(page < totalPages){\n            const url = \"\".concat(\"https://plugins-indicators-charitable-subtle.trycloudflare.com\", \"/\").concat(endpoint).concat(query).concat(query ? \"&\" : \"?\", \"page=\").concat(page, \"&size=50\");\n            // ðŸ”’ Seguridad: Timeout de 30 segundos\n            const controller = new AbortController();\n            const timeoutId = setTimeout(()=>controller.abort(), 30000);\n            try {\n                const res = await fetch(url, {\n                    headers: {\n                        Authorization: \"Bearer \".concat(token)\n                    },\n                    signal: controller.signal\n                });\n                clearTimeout(timeoutId);\n                if (!res.ok) {\n                    const errorText = await res.text();\n                    throw new Error(\"âŒ Error al traer datos p\\xe1gina \".concat(page, \": \").concat(res.status, \" - \").concat(errorText));\n                }\n                const data = await res.json();\n                var _data_content;\n                // asumimos que la API devuelve { content: [...], totalPages: N }\n                results = results.concat((_data_content = data.content) !== null && _data_content !== void 0 ? _data_content : []);\n                var _data_totalPages;\n                totalPages = (_data_totalPages = data.totalPages) !== null && _data_totalPages !== void 0 ? _data_totalPages : 1;\n                page++;\n            } catch (fetchError) {\n                if (fetchError.name === 'AbortError') {\n                    throw new Error('â±ï¸ Timeout: La peticiÃ³n tardÃ³ mÃ¡s de 30 segundos');\n                }\n                throw fetchError;\n            }\n        }\n        // Guardar en IndexedDB usando Dexie\n        return results; // ðŸ‘ˆ devuelve el array genÃ©rico\n    } catch (err) {\n        console.error(err);\n        return null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NlcnZpY2VzL3N5bmMudHMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBd0M7QUFHL0IsZUFBZUMsU0FDcEJDLFFBQWdCLEVBQ2hCQyxLQUFhLEVBQ2JDLFFBQWdCO1FBQ2hCQyxTQUFBQSxpRUFBOEIsQ0FBQztJQUUvQixNQUFNQyxXQUFXLE1BQU1OLHFEQUFjQTtJQUNyQyxNQUFNTyxRQUFRRCxxQkFBQUEsK0JBQUFBLFNBQVVFLE9BQU8sQ0FBQyxrQkFBa0IsSUFBSUMsSUFBSTtJQUMxRCxJQUFJO1FBQ0YscUNBQXFDO1FBQ3JDLE1BQU1DLGtCQUF1QyxDQUFDO1FBQzlDLEtBQUssTUFBTSxDQUFDQyxLQUFLQyxNQUFNLElBQUlDLE9BQU9DLE9BQU8sQ0FBQ1QsUUFBUztZQUNqRCxJQUFJLE9BQU9PLFVBQVUsVUFBVTtnQkFDN0JGLGVBQWUsQ0FBQ0MsSUFBSSxHQUFHQyxNQUFNRyxTQUFTLENBQUMsR0FBRyxNQUFNLG1CQUFtQjtZQUNyRSxPQUFPO2dCQUNMTCxlQUFlLENBQUNDLElBQUksR0FBR0M7WUFDekI7UUFDRjtRQUVBLCtCQUErQjtRQUMvQixJQUFJSSxRQUFRO1FBQ1osSUFBSUgsT0FBT0ksSUFBSSxDQUFDUCxpQkFBaUJRLE1BQU0sR0FBRyxHQUFHO1lBQzNDRixRQUNFLE1BQ0FILE9BQU9DLE9BQU8sQ0FBQ0osaUJBQ1pTLEdBQUcsQ0FBQztvQkFBQyxDQUFDUixLQUFLQyxNQUFNO3VCQUFLLEdBQVVRLE9BQVBULEtBQUksS0FBNkIsT0FBMUJTLG1CQUFtQlI7ZUFDbkRTLElBQUksQ0FBQztRQUNaO1FBRUEsSUFBSUMsT0FBTztRQUNYLElBQUlDLGFBQWE7UUFDakIsSUFBSUMsVUFBaUIsRUFBRSxFQUFFLGdEQUFnRDtRQUV6RSxNQUFPRixPQUFPQyxXQUFZO1lBQ3hCLE1BQU1FLE1BQU0sR0FBc0N2QixPQUFuQ3dCLGdFQUErQixFQUFDLEtBQWNWLE9BQVhkLFVBQ2hEYyxPQUQyREEsT0FFckRNLE9BRE5OLFFBQVEsTUFBTSxLQUNmLFNBQVksT0FBTE0sTUFBSztZQUViLHVDQUF1QztZQUN2QyxNQUFNTyxhQUFhLElBQUlDO1lBQ3ZCLE1BQU1DLFlBQVlDLFdBQVcsSUFBTUgsV0FBV0ksS0FBSyxJQUFJO1lBRXZELElBQUk7Z0JBQ0YsTUFBTUMsTUFBTSxNQUFNQyxNQUFNVixLQUFLO29CQUMzQlcsU0FBUzt3QkFDUEMsZUFBZSxVQUFnQixPQUFOOUI7b0JBQzNCO29CQUNBK0IsUUFBUVQsV0FBV1MsTUFBTTtnQkFDM0I7Z0JBQ0FDLGFBQWFSO2dCQUViLElBQUksQ0FBQ0csSUFBSU0sRUFBRSxFQUFFO29CQUNYLE1BQU1DLFlBQVksTUFBTVAsSUFBSVEsSUFBSTtvQkFDaEMsTUFBTSxJQUFJQyxNQUNSLG9DQUEwQ1QsT0FBVFosTUFBSyxNQUFvQm1CLE9BQWhCUCxJQUFJVSxNQUFNLEVBQUMsT0FBZSxPQUFWSDtnQkFFOUQ7Z0JBRUEsTUFBTUksT0FBTyxNQUFNWCxJQUFJWSxJQUFJO29CQUdGRDtnQkFEekIsaUVBQWlFO2dCQUNqRXJCLFVBQVVBLFFBQVF1QixNQUFNLENBQUNGLENBQUFBLGdCQUFBQSxLQUFLRyxPQUFPLGNBQVpILDJCQUFBQSxnQkFBZ0IsRUFBRTtvQkFDOUJBO2dCQUFidEIsYUFBYXNCLENBQUFBLG1CQUFBQSxLQUFLdEIsVUFBVSxjQUFmc0IsOEJBQUFBLG1CQUFtQjtnQkFDaEN2QjtZQUNGLEVBQUUsT0FBTzJCLFlBQWlCO2dCQUN4QixJQUFJQSxXQUFXQyxJQUFJLEtBQUssY0FBYztvQkFDcEMsTUFBTSxJQUFJUCxNQUFNO2dCQUNsQjtnQkFDQSxNQUFNTTtZQUNSO1FBQ0Y7UUFDRSxvQ0FBb0M7UUFDdEMsT0FBT3pCLFNBQVMsZ0NBQWdDO0lBQ2xELEVBQUUsT0FBTzJCLEtBQUs7UUFDWkMsUUFBUUMsS0FBSyxDQUFDRjtRQUNkLE9BQU87SUFDVDtBQUNGIiwic291cmNlcyI6WyJDOlxcZGVzYXJyb2xsb19yZWFjdFxccHJldmVudGFcXHNvZnR3YXJlLWNvbWVyY2lhbFxcc2VydmljZXNcXHN5bmMudHMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0QWNjZXNzVG9rZW4gfSBmcm9tIFwiLi9hdXRoXCI7XHJcblxyXG5cclxuICBleHBvcnQgYXN5bmMgZnVuY3Rpb24gc3luY0RhdGEoXHJcbiAgICBlbmRwb2ludDogc3RyaW5nLFxyXG4gICAgbGFiZWw6IHN0cmluZyxcclxuICAgIHByb2dyZXNzOiBudW1iZXIsXHJcbiAgICBwYXJhbXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fVxyXG4gICk6IFByb21pc2U8YW55W10gfCBudWxsPiB7ICAgIFxyXG4gICAgY29uc3QgcmF3VG9rZW4gPSBhd2FpdCBnZXRBY2Nlc3NUb2tlbigpO1xyXG4gICAgY29uc3QgdG9rZW4gPSByYXdUb2tlbj8ucmVwbGFjZSgvKFxcclxcbnxcXG58XFxyKS9nbSwgXCJcIikudHJpbSgpO1xyXG4gICAgdHJ5IHtcclxuICAgICAgLy8g8J+UkiBTZWd1cmlkYWQ6IFNhbml0aXphciBwYXLDoW1ldHJvc1xyXG4gICAgICBjb25zdCBzYW5pdGl6ZWRQYXJhbXM6IFJlY29yZDxzdHJpbmcsIGFueT4gPSB7fTtcclxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xyXG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBzYW5pdGl6ZWRQYXJhbXNba2V5XSA9IHZhbHVlLnN1YnN0cmluZygwLCAyMDApOyAvLyBsaW1pdGFyIGxvbmdpdHVkXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHNhbml0aXplZFBhcmFtc1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb25zdHJ1Y2Npw7NuIGRlIHF1ZXJ5IHN0cmluZ1xyXG4gICAgICBsZXQgcXVlcnkgPSBcIlwiO1xyXG4gICAgICBpZiAoT2JqZWN0LmtleXMoc2FuaXRpemVkUGFyYW1zKS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgcXVlcnkgPVxyXG4gICAgICAgICAgXCI/XCIgK1xyXG4gICAgICAgICAgT2JqZWN0LmVudHJpZXMoc2FuaXRpemVkUGFyYW1zKVxyXG4gICAgICAgICAgICAubWFwKChba2V5LCB2YWx1ZV0pID0+IGAke2tleX09JHtlbmNvZGVVUklDb21wb25lbnQodmFsdWUpfWApXHJcbiAgICAgICAgICAgIC5qb2luKFwiJlwiKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgbGV0IHBhZ2UgPSAwO1xyXG4gICAgICBsZXQgdG90YWxQYWdlcyA9IDE7XHJcbiAgICAgIGxldCByZXN1bHRzOiBhbnlbXSA9IFtdOyAvLyBnZW7DqXJpY28sIHB1ZWRlIHNlciBwcm9kdWN0b3MsIGNsaWVudGVzLCBldGMuXHJcblxyXG4gICAgICB3aGlsZSAocGFnZSA8IHRvdGFsUGFnZXMpIHtcclxuICAgICAgICBjb25zdCB1cmwgPSBgJHtwcm9jZXNzLmVudi5ORVhUX1BVQkxJQ19BUElfVVJMfS8ke2VuZHBvaW50fSR7cXVlcnl9JHtcclxuICAgICAgICAgIHF1ZXJ5ID8gXCImXCIgOiBcIj9cIlxyXG4gICAgICAgIH1wYWdlPSR7cGFnZX0mc2l6ZT01MGA7XHJcblxyXG4gICAgICAgIC8vIPCflJIgU2VndXJpZGFkOiBUaW1lb3V0IGRlIDMwIHNlZ3VuZG9zXHJcbiAgICAgICAgY29uc3QgY29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcclxuICAgICAgICBjb25zdCB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IGNvbnRyb2xsZXIuYWJvcnQoKSwgMzAwMDApO1xyXG5cclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2godXJsLCB7XHJcbiAgICAgICAgICAgIGhlYWRlcnM6IHtcclxuICAgICAgICAgICAgICBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dG9rZW59YCxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcblxyXG4gICAgICAgICAgaWYgKCFyZXMub2spIHtcclxuICAgICAgICAgICAgY29uc3QgZXJyb3JUZXh0ID0gYXdhaXQgcmVzLnRleHQoKTtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICAgIGDinYwgRXJyb3IgYWwgdHJhZXIgZGF0b3MgcMOhZ2luYSAke3BhZ2V9OiAke3Jlcy5zdGF0dXN9IC0gJHtlcnJvclRleHR9YFxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGNvbnN0IGRhdGEgPSBhd2FpdCByZXMuanNvbigpO1xyXG5cclxuICAgICAgICAgIC8vIGFzdW1pbW9zIHF1ZSBsYSBBUEkgZGV2dWVsdmUgeyBjb250ZW50OiBbLi4uXSwgdG90YWxQYWdlczogTiB9XHJcbiAgICAgICAgICByZXN1bHRzID0gcmVzdWx0cy5jb25jYXQoZGF0YS5jb250ZW50ID8/IFtdKTtcclxuICAgICAgICAgIHRvdGFsUGFnZXMgPSBkYXRhLnRvdGFsUGFnZXMgPz8gMTtcclxuICAgICAgICAgIHBhZ2UrKztcclxuICAgICAgICB9IGNhdGNoIChmZXRjaEVycm9yOiBhbnkpIHtcclxuICAgICAgICAgIGlmIChmZXRjaEVycm9yLm5hbWUgPT09ICdBYm9ydEVycm9yJykge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ+KPse+4jyBUaW1lb3V0OiBMYSBwZXRpY2nDs24gdGFyZMOzIG3DoXMgZGUgMzAgc2VndW5kb3MnKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIHRocm93IGZldGNoRXJyb3I7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgICAgLy8gR3VhcmRhciBlbiBJbmRleGVkREIgdXNhbmRvIERleGllXHJcbiAgICAgIHJldHVybiByZXN1bHRzOyAvLyDwn5GIIGRldnVlbHZlIGVsIGFycmF5IGdlbsOpcmljb1xyXG4gICAgfSBjYXRjaCAoZXJyKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKTtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgfTsiXSwibmFtZXMiOlsiZ2V0QWNjZXNzVG9rZW4iLCJzeW5jRGF0YSIsImVuZHBvaW50IiwibGFiZWwiLCJwcm9ncmVzcyIsInBhcmFtcyIsInJhd1Rva2VuIiwidG9rZW4iLCJyZXBsYWNlIiwidHJpbSIsInNhbml0aXplZFBhcmFtcyIsImtleSIsInZhbHVlIiwiT2JqZWN0IiwiZW50cmllcyIsInN1YnN0cmluZyIsInF1ZXJ5Iiwia2V5cyIsImxlbmd0aCIsIm1hcCIsImVuY29kZVVSSUNvbXBvbmVudCIsImpvaW4iLCJwYWdlIiwidG90YWxQYWdlcyIsInJlc3VsdHMiLCJ1cmwiLCJwcm9jZXNzIiwiZW52IiwiTkVYVF9QVUJMSUNfQVBJX1VSTCIsImNvbnRyb2xsZXIiLCJBYm9ydENvbnRyb2xsZXIiLCJ0aW1lb3V0SWQiLCJzZXRUaW1lb3V0IiwiYWJvcnQiLCJyZXMiLCJmZXRjaCIsImhlYWRlcnMiLCJBdXRob3JpemF0aW9uIiwic2lnbmFsIiwiY2xlYXJUaW1lb3V0Iiwib2siLCJlcnJvclRleHQiLCJ0ZXh0IiwiRXJyb3IiLCJzdGF0dXMiLCJkYXRhIiwianNvbiIsImNvbmNhdCIsImNvbnRlbnQiLCJmZXRjaEVycm9yIiwibmFtZSIsImVyciIsImNvbnNvbGUiLCJlcnJvciJdLCJpZ25vcmVMaXN0IjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./services/sync.ts\n"));

/***/ })

});